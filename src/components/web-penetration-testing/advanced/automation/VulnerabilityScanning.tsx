
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';
import { Search, Shield, Database, Clock } from 'lucide-react';

const VulnerabilityScanning: React.FC = () => {
  return (
    <Card className="bg-cybr-card border-cybr-muted">
      <CardHeader>
        <CardTitle className="text-cybr-primary flex items-center gap-2">
          <Search className="h-6 w-6" />
          Automated Vulnerability Scanning
        </CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="nmap-automation" className="w-full">
          <TabsList className="grid grid-cols-2 md:grid-cols-4 w-full mb-6">
            <TabsTrigger value="nmap-automation">Nmap Automation</TabsTrigger>
            <TabsTrigger value="nessus-api">Nessus API</TabsTrigger>
            <TabsTrigger value="openvas-automation">OpenVAS</TabsTrigger>
            <TabsTrigger value="scheduled-scanning">Scheduled Scans</TabsTrigger>
          </TabsList>

          <TabsContent value="nmap-automation" className="space-y-6">
            <div className="space-y-4">
              <h3 className="text-xl font-semibold text-cybr-primary">Nmap Automation Scripts</h3>
              
              <div className="bg-cybr-muted/20 p-4 rounded-lg">
                <h4 className="font-medium text-cybr-accent mb-2">Comprehensive Network Scanner</h4>
                <pre className="bg-cybr-background p-3 rounded text-sm overflow-x-auto">
{`#!/usr/bin/env python3
import nmap
import json
import csv
import threading
from datetime import datetime
import argparse
import xml.etree.ElementTree as ET

class NmapAutomation:
    def __init__(self, targets, output_format='json'):
        self.nm = nmap.PortScanner()
        self.targets = targets if isinstance(targets, list) else [targets]
        self.output_format = output_format
        self.scan_results = {}
        self.vulnerabilities = []
        
    def host_discovery(self, network):
        """Perform host discovery on a network"""
        print(f"[*] Performing host discovery on {network}")
        
        try:
            self.nm.scan(hosts=network, arguments='-sn -PE -PP -PS80,443 -PA3389 --source-port 53')
            alive_hosts = []
            
            for host in self.nm.all_hosts():
                if self.nm[host].state() == 'up':
                    alive_hosts.append(host)
                    print(f"[+] Host {host} is alive")
            
            return alive_hosts
        except Exception as e:
            print(f"[!] Error in host discovery: {e}")
            return []
    
    def port_scan(self, target, scan_type='comprehensive'):
        """Perform port scanning with different scan types"""
        scan_configs = {
            'quick': '-T4 -F',
            'comprehensive': '-T4 -A -sS -sV -O --script=default',
            'stealth': '-T2 -sS -Pn',
            'aggressive': '-T4 -A -sS -sV -O -sC --script=vuln',
            'udp': '-sU --top-ports 100',
            'tcp_connect': '-sT -p-'
        }
        
        print(f"[*] Starting {scan_type} port scan on {target}")
        
        try:
            scan_args = scan_configs.get(scan_type, scan_configs['comprehensive'])
            self.nm.scan(target, arguments=scan_args)
            
            result = {
                'host': target,
                'scan_type': scan_type,
                'timestamp': datetime.now().isoformat(),
                'state': self.nm[target].state() if target in self.nm.all_hosts() else 'down',
                'ports': {},
                'os_detection': {},
                'scripts': {}
            }
            
            if target in self.nm.all_hosts():
                # Port information
                for protocol in self.nm[target].all_protocols():
                    ports = self.nm[target][protocol].keys()
                    result['ports'][protocol] = {}
                    
                    for port in ports:
                        port_info = self.nm[target][protocol][port]
                        result['ports'][protocol][port] = {
                            'state': port_info['state'],
                            'name': port_info['name'],
                            'product': port_info.get('product', ''),
                            'version': port_info.get('version', ''),
                            'extrainfo': port_info.get('extrainfo', ''),
                            'cpe': port_info.get('cpe', '')
                        }
                
                # OS Detection
                if 'osmatch' in self.nm[target]:
                    result['os_detection'] = {
                        'matches': self.nm[target]['osmatch'],
                        'fingerprint': self.nm[target].get('osclass', [])
                    }
                
                # Script results
                if 'tcp' in self.nm[target]:
                    for port in self.nm[target]['tcp']:
                        if 'script' in self.nm[target]['tcp'][port]:
                            result['scripts'][port] = self.nm[target]['tcp'][port]['script']
            
            self.scan_results[target] = result
            print(f"[+] Scan completed for {target}")
            return result
            
        except Exception as e:
            print(f"[!] Error scanning {target}: {e}")
            return None
    
    def vulnerability_scan(self, target):
        """Run vulnerability-specific scripts"""
        print(f"[*] Running vulnerability scans on {target}")
        
        vuln_scripts = [
            'vuln',
            'exploit',
            'malware',
            'safe',
            'discovery',
            'version',
            'default'
        ]
        
        try:
            for script_category in vuln_scripts:
                print(f"[*] Running {script_category} scripts...")
                
                self.nm.scan(target, arguments=f'-sS -sV --script={script_category}')
                
                if target in self.nm.all_hosts():
                    for protocol in self.nm[target].all_protocols():
                        ports = self.nm[target][protocol].keys()
                        
                        for port in ports:
                            port_info = self.nm[target][protocol][port]
                            
                            if 'script' in port_info:
                                for script_name, script_output in port_info['script'].items():
                                    # Check for vulnerability indicators
                                    vuln_keywords = [
                                        'vulnerable', 'exploit', 'CVE-', 'VULNERABLE',
                                        'security hole', 'backdoor', 'weak'
                                    ]
                                    
                                    if any(keyword in script_output.upper() for keyword in vuln_keywords):
                                        vulnerability = {
                                            'host': target,
                                            'port': port,
                                            'protocol': protocol,
                                            'service': port_info.get('name', 'unknown'),
                                            'script': script_name,
                                            'output': script_output,
                                            'timestamp': datetime.now().isoformat()
                                        }
                                        
                                        self.vulnerabilities.append(vulnerability)
                                        print(f"[!] Vulnerability found on {target}:{port} - {script_name}")
        
        except Exception as e:
            print(f"[!] Error in vulnerability scan: {e}")
    
    def comprehensive_scan(self, parallel=True, max_threads=10):
        """Run comprehensive scans on all targets"""
        print(f"[*] Starting comprehensive scan of {len(self.targets)} targets")
        
        if parallel and len(self.targets) > 1:
            threads = []
            semaphore = threading.Semaphore(max_threads)
            
            def scan_worker(target):
                with semaphore:
                    self.port_scan(target, 'aggressive')
                    self.vulnerability_scan(target)
            
            for target in self.targets:
                thread = threading.Thread(target=scan_worker, args=(target,))
                thread.start()
                threads.append(thread)
            
            # Wait for all threads to complete
            for thread in threads:
                thread.join()
        
        else:
            for target in self.targets:
                self.port_scan(target, 'aggressive')
                self.vulnerability_scan(target)
    
    def export_results(self, filename=None):
        """Export scan results in various formats"""
        if not filename:
            filename = f"nmap_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # JSON Export
        json_data = {
            'scan_summary': {
                'targets_scanned': len(self.targets),
                'vulnerabilities_found': len(self.vulnerabilities),
                'scan_timestamp': datetime.now().isoformat()
            },
            'scan_results': self.scan_results,
            'vulnerabilities': self.vulnerabilities
        }
        
        with open(f"{filename}.json", 'w') as f:
            json.dump(json_data, f, indent=2)
        
        # CSV Export for vulnerabilities
        if self.vulnerabilities:
            with open(f"{filename}_vulnerabilities.csv", 'w', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=self.vulnerabilities[0].keys())
                writer.writeheader()
                writer.writerows(self.vulnerabilities)
        
        # HTML Report
        self.generate_html_report(f"{filename}.html")
        
        print(f"[+] Results exported to {filename}.*")
    
    def generate_html_report(self, filename):
        """Generate HTML report"""
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Nmap Scan Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #2c3e50; color: white; padding: 20px; }}
                .summary {{ background: #ecf0f1; padding: 15px; margin: 10px 0; }}
                .vulnerability {{ background: #e74c3c; color: white; padding: 10px; margin: 5px 0; }}
                .host {{ background: #3498db; color: white; padding: 10px; margin: 10px 0; }}
                .port {{ background: #95a5a6; color: white; padding: 5px; margin: 2px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Nmap Automated Scan Report</h1>
                <p>Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
            
            <div class="summary">
                <h2>Scan Summary</h2>
                <p>Targets Scanned: {len(self.targets)}</p>
                <p>Vulnerabilities Found: {len(self.vulnerabilities)}</p>
            </div>
        """
        
        # Add vulnerability details
        if self.vulnerabilities:
            html_content += "<h2>Vulnerabilities Found</h2>"
            for vuln in self.vulnerabilities:
                html_content += f"""
                <div class="vulnerability">
                    <h3>{vuln['host']}:{vuln['port']} - {vuln['script']}</h3>
                    <p><strong>Service:</strong> {vuln['service']}</p>
                    <p><strong>Output:</strong> {vuln['output'][:500]}...</p>
                </div>
                """
        
        # Add host details
        html_content += "<h2>Host Details</h2>"
        for host, details in self.scan_results.items():
            html_content += f"""
            <div class="host">
                <h3>Host: {host} ({details['state']})</h3>
                <p><strong>Scan Type:</strong> {details['scan_type']}</p>
                <p><strong>Timestamp:</strong> {details['timestamp']}</p>
            """
            
            if 'tcp' in details['ports']:
                html_content += "<h4>Open TCP Ports:</h4>"
                for port, port_info in details['ports']['tcp'].items():
                    if port_info['state'] == 'open':
                        html_content += f"""
                        <div class="port">
                            Port {port}: {port_info['name']} - {port_info['product']} {port_info['version']}
                        </div>
                        """
            
            html_content += "</div>"
        
        html_content += "</body></html>"
        
        with open(filename, 'w') as f:
            f.write(html_content)

# Command line interface
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Automated Nmap Scanner')
    parser.add_argument('targets', nargs='+', help='Target hosts or networks')
    parser.add_argument('-o', '--output', default=None, help='Output filename prefix')
    parser.add_argument('-t', '--threads', type=int, default=10, help='Max threads for parallel scanning')
    parser.add_argument('--discover', action='store_true', help='Perform host discovery first')
    
    args = parser.parse_args()
    
    # Host discovery if requested
    if args.discover:
        for target in args.targets:
            if '/' in target:  # Network range
                scanner = NmapAutomation([])
                alive_hosts = scanner.host_discovery(target)
                args.targets.extend(alive_hosts)
    
    # Initialize and run scanner
    scanner = NmapAutomation(args.targets)
    scanner.comprehensive_scan(parallel=True, max_threads=args.threads)
    scanner.export_results(args.output)
    
    print(f"\\n[+] Scan completed!")
    print(f"[+] Hosts scanned: {len(scanner.targets)}")
    print(f"[+] Vulnerabilities found: {len(scanner.vulnerabilities)}")
    
    if scanner.vulnerabilities:
        print("\\n[!] Vulnerabilities Summary:")
        for vuln in scanner.vulnerabilities[:5]:  # Show first 5
            print(f"  - {vuln['host']}:{vuln['port']} - {vuln['script']}")
        
        if len(scanner.vulnerabilities) > 5:
            print(f"  ... and {len(scanner.vulnerabilities) - 5} more")
            
# Usage Examples:
# python nmap_automation.py 192.168.1.1
# python nmap_automation.py 192.168.1.0/24 --discover -t 20
# python nmap_automation.py scanme.nmap.org google.com -o my_scan`}
                </pre>
              </div>
            </div>
          </TabsContent>

          <TabsContent value="nessus-api" className="space-y-6">
            <div className="space-y-4">
              <h3 className="text-xl font-semibold text-cybr-primary">Nessus API Integration</h3>
              
              <div className="bg-cybr-muted/20 p-4 rounded-lg">
                <h4 className="font-medium text-cybr-accent mb-2">Automated Nessus Scanning</h4>
                <pre className="bg-cybr-background p-3 rounded text-sm overflow-x-auto">
{`import requests
import time
import json
import urllib3
from requests.auth import HTTPBasicAuth

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class NessusAPI:
    def __init__(self, url, access_key, secret_key):
        self.url = url.rstrip('/')
        self.access_key = access_key
        self.secret_key = secret_key
        self.headers = {
            'X-ApiKeys': f'accessKey={access_key}; secretKey={secret_key}',
            'Content-Type': 'application/json'
        }
        self.session = requests.Session()
        self.session.verify = False
        
    def get_scanners(self):
        """Get list of available scanners"""
        response = self.session.get(f'{self.url}/scanners', headers=self.headers)
        return response.json() if response.status_code == 200 else None
    
    def get_policies(self):
        """Get scan policies"""
        response = self.session.get(f'{self.url}/policies', headers=self.headers)
        return response.json() if response.status_code == 200 else None
    
    def get_scan_templates(self):
        """Get available scan templates"""
        response = self.session.get(f'{self.url}/editor/scan/templates', headers=self.headers)
        return response.json() if response.status_code == 200 else None
    
    def create_scan(self, name, targets, template_uuid, scanner_id=1):
        """Create a new scan"""
        scan_data = {
            'uuid': template_uuid,
            'settings': {
                'name': name,
                'text_targets': targets,
                'scanner_id': scanner_id,
                'enabled': True,
                'launch': 'ONETIME'
            }
        }
        
        response = self.session.post(f'{self.url}/scans', 
                                   headers=self.headers, 
                                   json=scan_data)
        
        if response.status_code == 200:
            return response.json()['scan']['id']
        else:
            print(f"Error creating scan: {response.text}")
            return None
    
    def launch_scan(self, scan_id):
        """Launch a scan"""
        response = self.session.post(f'{self.url}/scans/{scan_id}/launch', 
                                   headers=self.headers)
        return response.status_code == 200
    
    def get_scan_status(self, scan_id):
        """Get scan status"""
        response = self.session.get(f'{self.url}/scans/{scan_id}', 
                                  headers=self.headers)
        
        if response.status_code == 200:
            data = response.json()
            return {
                'status': data['info']['status'],
                'progress': data['info'].get('progress', 0),
                'start_time': data['info'].get('timestamp', ''),
                'name': data['info']['name']
            }
        return None
    
    def wait_for_scan_completion(self, scan_id, check_interval=30):
        """Wait for scan to complete"""
        print(f"Waiting for scan {scan_id} to complete...")
        
        while True:
            status = self.get_scan_status(scan_id)
            if not status:
                print("Error getting scan status")
                return False
            
            print(f"Scan status: {status['status']}, Progress: {status['progress']}%")
            
            if status['status'] in ['completed', 'canceled', 'aborted']:
                print(f"Scan finished with status: {status['status']}")
                return status['status'] == 'completed'
            
            time.sleep(check_interval)
    
    def export_scan(self, scan_id, format_type='nessus'):
        """Export scan results"""
        export_data = {
            'format': format_type,  # 'nessus', 'csv', 'html', 'pdf'
            'chapters': 'vuln_hosts_summary;vuln_by_host;compliance_exec;remediations;vuln_by_plugin'
        }
        
        response = self.session.post(f'{self.url}/scans/{scan_id}/export', 
                                   headers=self.headers, 
                                   json=export_data)
        
        if response.status_code == 200:
            return response.json()['file']
        return None
    
    def download_export(self, scan_id, file_id, filename=None):
        """Download exported scan file"""
        response = self.session.get(f'{self.url}/scans/{scan_id}/export/{file_id}/download', 
                                  headers=self.headers)
        
        if response.status_code == 200:
            if not filename:
                filename = f'scan_{scan_id}_export.nessus'
            
            with open(filename, 'wb') as f:
                f.write(response.content)
            
            print(f"Export downloaded: {filename}")
            return filename
        
        return None
    
    def get_scan_vulnerabilities(self, scan_id):
        """Get vulnerabilities from scan"""
        response = self.session.get(f'{self.url}/scans/{scan_id}', 
                                  headers=self.headers)
        
        if response.status_code != 200:
            return []
        
        scan_data = response.json()
        vulnerabilities = []
        
        if 'vulnerabilities' in scan_data:
            for vuln in scan_data['vulnerabilities']:
                vulnerability = {
                    'plugin_id': vuln['plugin_id'],
                    'plugin_name': vuln['plugin_name'],
                    'plugin_family': vuln['plugin_family'],
                    'count': vuln['count'],
                    'severity': vuln['severity']
                }
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities

class AutomatedNessusScanner:
    def __init__(self, nessus_url, access_key, secret_key):
        self.api = NessusAPI(nessus_url, access_key, secret_key)
        self.scan_templates = {
            'basic_network': '731a8e52-3ea6-a291-ec0a-d2ff0619c19d7bd788d6',
            'advanced_scan': 'ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260',
            'web_application': '4dbf7a4b-8a6e-4b2a-a8c6-e6e1da19b4c4',
            'malware_scan': 'ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260'
        }
        
    def run_comprehensive_scan(self, targets, scan_name=None):
        """Run a comprehensive automated scan"""
        if not scan_name:
            scan_name = f"Automated_Scan_{int(time.time())}"
        
        print(f"Starting comprehensive scan: {scan_name}")
        print(f"Targets: {targets}")
        
        # Create scan with advanced template
        template_uuid = self.scan_templates['advanced_scan']
        scan_id = self.api.create_scan(scan_name, targets, template_uuid)
        
        if not scan_id:
            print("Failed to create scan")
            return None
        
        print(f"Scan created with ID: {scan_id}")
        
        # Launch scan
        if not self.api.launch_scan(scan_id):
            print("Failed to launch scan")
            return None
        
        print("Scan launched successfully")
        
        # Wait for completion
        if not self.api.wait_for_scan_completion(scan_id):
            print("Scan did not complete successfully")
            return None
        
        # Get results
        vulnerabilities = self.api.get_scan_vulnerabilities(scan_id)
        
        # Export results
        export_formats = ['nessus', 'csv', 'html']
        exported_files = []
        
        for fmt in export_formats:
            print(f"Exporting in {fmt} format...")
            file_id = self.api.export_scan(scan_id, fmt)
            
            if file_id:
                # Wait for export to be ready
                time.sleep(10)
                filename = f"{scan_name}.{fmt}"
                downloaded_file = self.api.download_export(scan_id, file_id, filename)
                if downloaded_file:
                    exported_files.append(downloaded_file)
        
        return {
            'scan_id': scan_id,
            'vulnerabilities': vulnerabilities,
            'exported_files': exported_files,
            'summary': self.analyze_vulnerabilities(vulnerabilities)
        }
    
    def analyze_vulnerabilities(self, vulnerabilities):
        """Analyze vulnerability results"""
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        total_vulns = 0
        
        for vuln in vulnerabilities:
            total_vulns += vuln['count']
            severity = {0: 'info', 1: 'low', 2: 'medium', 3: 'high', 4: 'critical'}
            sev_name = severity.get(vuln['severity'], 'unknown')
            severity_counts[sev_name] += vuln['count']
        
        return {
            'total_vulnerabilities': total_vulns,
            'unique_vulnerabilities': len(vulnerabilities),
            'severity_breakdown': severity_counts,
            'risk_score': (severity_counts['critical'] * 10 + 
                          severity_counts['high'] * 7 + 
                          severity_counts['medium'] * 4 + 
                          severity_counts['low'] * 1)
        }
    
    def schedule_recurring_scans(self, targets_list, scan_frequency='weekly'):
        """Schedule recurring scans for multiple target sets"""
        import schedule
        
        def run_scheduled_scan(targets, name):
            result = self.run_comprehensive_scan(targets, f"Scheduled_{name}_{int(time.time())}")
            if result:
                print(f"Scheduled scan completed for {name}")
                # Send notification or save results
                self.save_scan_results(result, f"scheduled_{name}")
        
        # Schedule scans based on frequency
        for i, targets in enumerate(targets_list):
            scan_name = f"TargetSet_{i+1}"
            
            if scan_frequency == 'daily':
                schedule.every().day.at("02:00").do(run_scheduled_scan, targets, scan_name)
            elif scan_frequency == 'weekly':
                schedule.every().week.do(run_scheduled_scan, targets, scan_name)
            elif scan_frequency == 'monthly':
                schedule.every(30).days.do(run_scheduled_scan, targets, scan_name)
        
        print(f"Scheduled {len(targets_list)} recurring scans with {scan_frequency} frequency")
        
        # Run scheduler
        while True:
            schedule.run_pending()
            time.sleep(3600)  # Check every hour
    
    def save_scan_results(self, results, prefix="scan"):
        """Save scan results to JSON file"""
        filename = f"{prefix}_{int(time.time())}.json"
        with open(filename, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"Results saved to {filename}")

# Usage example
if __name__ == "__main__":
    # Configuration
    NESSUS_URL = "https://your-nessus-server:8834"
    ACCESS_KEY = "your-access-key"
    SECRET_KEY = "your-secret-key"
    
    # Initialize scanner
    scanner = AutomatedNessusScanner(NESSUS_URL, ACCESS_KEY, SECRET_KEY)
    
    # Run single comprehensive scan
    targets = "192.168.1.0/24,10.0.0.1-10.0.0.50"
    results = scanner.run_comprehensive_scan(targets, "Production_Network_Scan")
    
    if results:
        print("\\n=== SCAN SUMMARY ===")
        summary = results['summary']
        print(f"Total Vulnerabilities: {summary['total_vulnerabilities']}")
        print(f"Unique Vulnerabilities: {summary['unique_vulnerabilities']}")
        print(f"Risk Score: {summary['risk_score']}")
        print("\\nSeverity Breakdown:")
        for severity, count in summary['severity_breakdown'].items():
            if count > 0:
                print(f"  {severity.capitalize()}: {count}")
        
        print(f"\\nExported Files: {', '.join(results['exported_files'])}")
    
    # Example: Schedule recurring scans
    # target_sets = [
    #     "192.168.1.0/24",
    #     "10.0.0.0/24", 
    #     "172.16.0.0/24"
    # ]
    # scanner.schedule_recurring_scans(target_sets, 'weekly')`}
                </pre>
              </div>
            </div>
          </TabsContent>

          <TabsContent value="openvas-automation" className="space-y-6">
            <div className="space-y-4">
              <h3 className="text-xl font-semibold text-cybr-primary">OpenVAS Automation</h3>
              
              <div className="bg-cybr-muted/20 p-4 rounded-lg">
                <h4 className="font-medium text-cybr-accent mb-2">GVM/OpenVAS API Integration</h4>
                <pre className="bg-cybr-background p-3 rounded text-sm overflow-x-auto">
{`# OpenVAS/GVM Automation Script
import xml.etree.ElementTree as ET
import socket
import ssl
import base64
import uuid
import time

class OpenVASAPI:
    def __init__(self, host, port=9390, username='admin', password='admin'):
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.socket = None
        self.authenticated = False
        
    def connect(self):
        """Connect to OpenVAS Manager"""
        try:
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Create socket connection
            sock = socket.create_connection((self.host, self.port))
            self.socket = context.wrap_socket(sock, server_hostname=self.host)
            
            print(f"Connected to OpenVAS at {self.host}:{self.port}")
            return True
            
        except Exception as e:
            print(f"Connection failed: {e}")
            return False
    
    def send_command(self, command):
        """Send GMP command to OpenVAS"""
        if not self.socket:
            return None
            
        try:
            # Send command
            self.socket.send(command.encode('utf-8'))
            
            # Receive response
            response = b""
            while True:
                chunk = self.socket.recv(4096)
                if not chunk:
                    break
                response += chunk
                if b'</get_version_response>' in response or b'</get_tasks_response>' in response:
                    break
            
            return response.decode('utf-8')
            
        except Exception as e:
            print(f"Command failed: {e}")
            return None
    
    def authenticate(self):
        """Authenticate with OpenVAS"""
        auth_command = f"""<authenticate>
            <credentials>
                <username>{self.username}</username>
                <password>{self.password}</password>
            </credentials>
        </authenticate>"""
        
        response = self.send_command(auth_command)
        
        if response and 'status="200"' in response:
            self.authenticated = True
            print("Authentication successful")
            return True
        else:
            print("Authentication failed")
            return False
    
    def get_version(self):
        """Get OpenVAS version"""
        command = "<get_version/>"
        return self.send_command(command)
    
    def create_target(self, name, hosts, port_list_id=None):
        """Create scan target"""
        if not port_list_id:
            port_list_id = "4a4717fe-57d2-11e1-9a26-406186ea4fc5"  # OpenVAS Default
        
        target_id = str(uuid.uuid4())
        
        command = f"""<create_target>
            <name>{name}</name>
            <hosts>{hosts}</hosts>
            <port_list id="{port_list_id}"/>
        </create_target>"""
        
        response = self.send_command(command)
        
        if response and 'status="201"' in response:
            # Extract target ID from response
            root = ET.fromstring(response)
            target_id = root.get('id')
            print(f"Target created: {target_id}")
            return target_id
        
        return None
    
    def create_task(self, name, target_id, scanner_id=None, config_id=None):
        """Create scan task"""
        if not scanner_id:
            scanner_id = "08b69003-5fc2-4037-a479-93b440211c73"  # OpenVAS Scanner
        
        if not config_id:
            config_id = "daba56c8-73ec-11df-a475-002264764cea"  # Full and fast
        
        command = f"""<create_task>
            <name>{name}</name>
            <config id="{config_id}"/>
            <target id="{target_id}"/>
            <scanner id="{scanner_id}"/>
        </create_task>"""
        
        response = self.send_command(command)
        
        if response and 'status="201"' in response:
            root = ET.fromstring(response)
            task_id = root.get('id')
            print(f"Task created: {task_id}")
            return task_id
        
        return None
    
    def start_task(self, task_id):
        """Start scan task"""
        command = f'<start_task task_id="{task_id}"/>'
        response = self.send_command(command)
        
        if response and 'status="202"' in response:
            print(f"Task {task_id} started")
            return True
        
        return False
    
    def get_task_status(self, task_id):
        """Get task status"""
        command = f'<get_tasks task_id="{task_id}"/>'
        response = self.send_command(command)
        
        if response:
            root = ET.fromstring(response)
            task = root.find('task')
            if task is not None:
                status = task.find('status').text
                progress = task.find('progress').text if task.find('progress') is not None else "0"
                return status, progress
        
        return None, None
    
    def wait_for_task_completion(self, task_id, check_interval=30):
        """Wait for task to complete"""
        print(f"Waiting for task {task_id} to complete...")
        
        while True:
            status, progress = self.get_task_status(task_id)
            
            if not status:
                print("Error getting task status")
                return False
            
            print(f"Task status: {status}, Progress: {progress}%")
            
            if status in ['Done', 'Stopped', 'Interrupted']:
                print(f"Task completed with status: {status}")
                return status == 'Done'
            
            time.sleep(check_interval)
    
    def get_results(self, task_id):
        """Get scan results"""
        command = f'<get_results task_id="{task_id}"/>'
        response = self.send_command(command)
        
        if response:
            return self.parse_results(response)
        
        return []
    
    def parse_results(self, xml_response):
        """Parse XML results into structured data"""
        try:
            root = ET.fromstring(xml_response)
            results = []
            
            for result in root.findall('.//result'):
                result_data = {
                    'id': result.get('id'),
                    'name': result.find('name').text if result.find('name') is not None else '',
                    'host': result.find('host').text if result.find('host') is not None else '',
                    'port': result.find('port').text if result.find('port') is not None else '',
                    'threat': result.find('threat').text if result.find('threat') is not None else '',
                    'severity': result.find('severity').text if result.find('severity') is not None else '',
                    'description': result.find('description').text if result.find('description') is not None else ''
                }
                results.append(result_data)
            
            return results
            
        except ET.ParseError as e:
            print(f"Error parsing results: {e}")
            return []
    
    def export_results(self, task_id, format_type='xml'):
        """Export results in specified format"""
        # Get available report formats
        format_ids = {
            'xml': 'a994b278-1f62-11e1-96ac-406186ea4fc5',
            'html': '6c248850-1f62-11e1-b082-406186ea4fc5',
            'pdf': 'c402cc3e-b531-11e1-9163-406186ea4fc5',
            'csv': 'c1645568-627a-11e3-a660-406186ea4fc5'
        }
        
        format_id = format_ids.get(format_type, format_ids['xml'])
        
        # Create report
        command = f"""<create_report>
            <task id="{task_id}"/>
            <format id="{format_id}"/>
        </create_report>"""
        
        response = self.send_command(command)
        
        if response and 'status="201"' in response:
            root = ET.fromstring(response)
            report_id = root.get('id')
            
            # Get report
            command = f'<get_reports report_id="{report_id}" format_id="{format_id}"/>'
            report_response = self.send_command(command)
            
            if report_response:
                # Save report to file
                filename = f"openvas_report_{task_id}.{format_type}"
                with open(filename, 'w') as f:
                    f.write(report_response)
                print(f"Report exported: {filename}")
                return filename
        
        return None
    
    def disconnect(self):
        """Close connection"""
        if self.socket:
            self.socket.close()
            print("Disconnected from OpenVAS")

class OpenVASAutomation:
    def __init__(self, host, username='admin', password='admin'):
        self.api = OpenVASAPI(host, username=username, password=password)
        
    def run_comprehensive_scan(self, targets, scan_name="Automated_Scan"):
        """Run complete automated scan"""
        print(f"Starting OpenVAS automation for: {targets}")
        
        # Connect and authenticate
        if not self.api.connect():
            return None
        
        if not self.api.authenticate():
            return None
        
        try:
            # Create target
            target_id = self.api.create_target(f"{scan_name}_Target", targets)
            if not target_id:
                print("Failed to create target")
                return None
            
            # Create task
            task_id = self.api.create_task(scan_name, target_id)
            if not task_id:
                print("Failed to create task")
                return None
            
            # Start scan
            if not self.api.start_task(task_id):
                print("Failed to start task")
                return None
            
            # Wait for completion
            if not self.api.wait_for_task_completion(task_id):
                print("Scan did not complete successfully")
                return None
            
            # Get results
            results = self.api.get_results(task_id)
            
            # Export reports
            exported_files = []
            for fmt in ['xml', 'html', 'csv']:
                filename = self.api.export_results(task_id, fmt)
                if filename:
                    exported_files.append(filename)
            
            return {
                'task_id': task_id,
                'target_id': target_id,
                'results': results,
                'exported_files': exported_files,
                'summary': self.analyze_results(results)
            }
            
        finally:
            self.api.disconnect()
    
    def analyze_results(self, results):
        """Analyze scan results"""
        severity_counts = {'High': 0, 'Medium': 0, 'Low': 0, 'Log': 0}
        hosts_affected = set()
        
        for result in results:
            threat = result.get('threat', 'Log')
            severity_counts[threat] = severity_counts.get(threat, 0) + 1
            hosts_affected.add(result.get('host', ''))
        
        return {
            'total_findings': len(results),
            'hosts_affected': len(hosts_affected),
            'severity_breakdown': severity_counts,
            'risk_score': (severity_counts.get('High', 0) * 10 + 
                          severity_counts.get('Medium', 0) * 5 + 
                          severity_counts.get('Low', 0) * 1)
        }

# Usage example
if __name__ == "__main__":
    # Configuration
    OPENVAS_HOST = "192.168.1.100"  # Your OpenVAS server
    USERNAME = "admin"
    PASSWORD = "your_password"
    
    # Initialize automation
    scanner = OpenVASAutomation(OPENVAS_HOST, USERNAME, PASSWORD)
    
    # Run scan
    targets = "192.168.1.0/24"
    results = scanner.run_comprehensive_scan(targets, "Production_Network_Scan")
    
    if results:
        print("\\n=== OPENVAS SCAN SUMMARY ===")
        summary = results['summary']
        print(f"Total Findings: {summary['total_findings']}")
        print(f"Hosts Affected: {summary['hosts_affected']}")
        print(f"Risk Score: {summary['risk_score']}")
        print("\\nSeverity Breakdown:")
        for severity, count in summary['severity_breakdown'].items():
            if count > 0:
                print(f"  {severity}: {count}")
        
        print(f"\\nExported Files: {', '.join(results['exported_files'])}")
        
        # Show top 5 findings
        print("\\nTop Findings:")
        for i, finding in enumerate(results['results'][:5], 1):
            print(f"{i}. {finding['name']} on {finding['host']}")
            print(f"   Threat: {finding['threat']}, Port: {finding['port']}")
            print(f"   {finding['description'][:100]}...")
            print()`}
                </pre>
              </div>
            </div>
          </TabsContent>

          <TabsContent value="scheduled-scanning" className="space-y-6">
            <div className="space-y-4">
              <h3 className="text-xl font-semibold text-cybr-primary">Scheduled & Continuous Scanning</h3>
              
              <div className="bg-cybr-muted/20 p-4 rounded-lg">
                <h4 className="font-medium text-cybr-accent mb-2">Automated Scheduling Framework</h4>
                <pre className="bg-cybr-background p-3 rounded text-sm overflow-x-auto">
{`import schedule
import time
import threading
import logging
import json
import sqlite3
from datetime import datetime, timedelta
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pathlib import Path

class ScanScheduler:
    def __init__(self, db_path="scan_scheduler.db"):
        self.db_path = db_path
        self.running = False
        self.scheduler_thread = None
        self.setup_database()
        self.setup_logging()
        
    def setup_database(self):
        """Initialize SQLite database for scan tracking"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scheduled_scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                targets TEXT NOT NULL,
                scan_type TEXT NOT NULL,
                frequency TEXT NOT NULL,
                last_run DATETIME,
                next_run DATETIME,
                status TEXT DEFAULT 'active',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scan_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id INTEGER,
                run_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                status TEXT,
                vulnerabilities_found INTEGER,
                risk_score INTEGER,
                report_path TEXT,
                FOREIGN KEY (scan_id) REFERENCES scheduled_scans (id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def setup_logging(self):
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('scan_scheduler.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger('ScanScheduler')
    
    def add_scheduled_scan(self, name, targets, scan_type, frequency, scanner_config=None):
        """Add a new scheduled scan"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO scheduled_scans (name, targets, scan_type, frequency)
            VALUES (?, ?, ?, ?)
        ''', (name, targets, scan_type, frequency))
        
        scan_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        # Schedule the scan
        self.schedule_scan(scan_id, frequency)
        
        self.logger.info(f"Added scheduled scan: {name} ({frequency})")
        return scan_id
    
    def schedule_scan(self, scan_id, frequency):
        """Schedule a scan based on frequency"""
        def run_scheduled_scan():
            self.execute_scan(scan_id)
        
        if frequency == 'daily':
            schedule.every().day.at("02:00").do(run_scheduled_scan).tag(f'scan_{scan_id}')
        elif frequency == 'weekly':
            schedule.every().monday.at("02:00").do(run_scheduled_scan).tag(f'scan_{scan_id}')
        elif frequency == 'monthly':
            schedule.every(30).days.do(run_scheduled_scan).tag(f'scan_{scan_id}')
        elif frequency == 'hourly':
            schedule.every().hour.do(run_scheduled_scan).tag(f'scan_{scan_id}')
        
        self.logger.info(f"Scheduled scan {scan_id} with frequency: {frequency}")
    
    def execute_scan(self, scan_id):
        """Execute a scheduled scan"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get scan details
        cursor.execute('SELECT * FROM scheduled_scans WHERE id = ?', (scan_id,))
        scan = cursor.fetchone()
        
        if not scan:
            self.logger.error(f"Scan {scan_id} not found")
            return
        
        name, targets, scan_type = scan[1], scan[2], scan[3]
        
        self.logger.info(f"Executing scheduled scan: {name}")
        
        try:
            # Update last run time
            cursor.execute('''
                UPDATE scheduled_scans 
                SET last_run = CURRENT_TIMESTAMP 
                WHERE id = ?
            ''', (scan_id,))
            
            # Execute the actual scan based on type
            result = self.run_scan_by_type(scan_type, targets, name)
            
            if result:
                # Save scan results
                cursor.execute('''
                    INSERT INTO scan_results 
                    (scan_id, status, vulnerabilities_found, risk_score, report_path)
                    VALUES (?, ?, ?, ?, ?)
                ''', (scan_id, 'completed', result.get('vulnerabilities', 0), 
                      result.get('risk_score', 0), result.get('report_path', '')))
                
                self.logger.info(f"Scan {name} completed successfully")
                
                # Send notification if configured
                self.send_notification(scan_id, result)
            else:
                cursor.execute('''
                    INSERT INTO scan_results (scan_id, status)
                    VALUES (?, ?)
                ''', (scan_id, 'failed'))
                
                self.logger.error(f"Scan {name} failed")
        
        except Exception as e:
            self.logger.error(f"Error executing scan {name}: {e}")
            cursor.execute('''
                INSERT INTO scan_results (scan_id, status)
                VALUES (?, ?)
            ''', (scan_id, 'error'))
        
        finally:
            conn.commit()
            conn.close()
    
    def run_scan_by_type(self, scan_type, targets, name):
        """Execute scan based on scan type"""
        if scan_type == 'nmap':
            return self.run_nmap_scan(targets, name)
        elif scan_type == 'nessus':
            return self.run_nessus_scan(targets, name)
        elif scan_type == 'openvas':
            return self.run_openvas_scan(targets, name)
        elif scan_type == 'custom':
            return self.run_custom_scan(targets, name)
        else:
            self.logger.error(f"Unknown scan type: {scan_type}")
            return None
    
    def run_nmap_scan(self, targets, name):
        """Run Nmap scan"""
        import subprocess
        import xml.etree.ElementTree as ET
        
        try:
            # Run nmap scan
            output_file = f"nmap_{name}_{int(time.time())}.xml"
            cmd = f"nmap -sS -sV -O -A --script=vuln -oX {output_file} {targets}"
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                # Parse results
                tree = ET.parse(output_file)
                root = tree.getroot()
                
                vulnerabilities = 0
                risk_score = 0
                
                # Count vulnerabilities and calculate risk
                for host in root.findall('host'):
                    for port in host.findall('.//port'):
                        scripts = port.findall('.//script')
                        for script in scripts:
                            if 'vuln' in script.get('id', ''):
                                vulnerabilities += 1
                                risk_score += 5  # Basic risk scoring
                
                return {
                    'vulnerabilities': vulnerabilities,
                    'risk_score': risk_score,
                    'report_path': output_file,
                    'status': 'completed'
                }
            
        except Exception as e:
            self.logger.error(f"Nmap scan error: {e}")
        
        return None
    
    def run_nessus_scan(self, targets, name):
        """Run Nessus scan using API"""
        # This would integrate with the NessusAPI class from previous example
        try:
            from nessus_api import AutomatedNessusScanner
            
            scanner = AutomatedNessusScanner(
                "https://nessus-server:8834",
                "access_key",
                "secret_key"
            )
            
            result = scanner.run_comprehensive_scan(targets, name)
            return result
            
        except Exception as e:
            self.logger.error(f"Nessus scan error: {e}")
            return None
    
    def run_openvas_scan(self, targets, name):
        """Run OpenVAS scan"""
        # This would integrate with the OpenVASAPI class
        try:
            from openvas_api import OpenVASAutomation
            
            scanner = OpenVASAutomation("openvas-server", "admin", "password")
            result = scanner.run_comprehensive_scan(targets, name)
            return result
            
        except Exception as e:
            self.logger.error(f"OpenVAS scan error: {e}")
            return None
    
    def run_custom_scan(self, targets, name):
        """Run custom scan script"""
        try:
            # Execute custom scanning logic
            vulnerabilities = 0
            risk_score = 0
            
            # Custom scan implementation here
            # This could call external scripts or tools
            
            return {
                'vulnerabilities': vulnerabilities,
                'risk_score': risk_score,
                'report_path': f"custom_{name}_{int(time.time())}.json",
                'status': 'completed'
            }
            
        except Exception as e:
            self.logger.error(f"Custom scan error: {e}")
            return None
    
    def send_notification(self, scan_id, result):
        """Send email notification for scan completion"""
        try:
            # Email configuration
            smtp_server = "smtp.gmail.com"
            smtp_port = 587
            sender_email = "scanner@company.com"
            sender_password = "app_password"
            recipient_email = "security@company.com"
            
            # Get scan details
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute('SELECT name, targets FROM scheduled_scans WHERE id = ?', (scan_id,))
            scan_name, targets = cursor.fetchone()
            conn.close()
            
            # Create email
            msg = MIMEMultipart()
            msg['From'] = sender_email
            msg['To'] = recipient_email
            msg['Subject'] = f"Scan Completed: {scan_name}"
            
            body = f"""
            Scheduled scan '{scan_name}' has completed.
            
            Targets: {targets}
            Vulnerabilities Found: {result.get('vulnerabilities', 0)}
            Risk Score: {result.get('risk_score', 0)}
            Report Path: {result.get('report_path', 'N/A')}
            
            Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            """
            
            msg.attach(MIMEText(body, 'plain'))
            
            # Send email
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(msg)
            server.quit()
            
            self.logger.info(f"Notification sent for scan: {scan_name}")
            
        except Exception as e:
            self.logger.error(f"Failed to send notification: {e}")
    
    def start_scheduler(self):
        """Start the scheduler in a separate thread"""
        if self.running:
            return
        
        self.running = True
        
        def scheduler_loop():
            while self.running:
                schedule.run_pending()
                time.sleep(60)  # Check every minute
        
        self.scheduler_thread = threading.Thread(target=scheduler_loop, daemon=True)
        self.scheduler_thread.start()
        
        self.logger.info("Scan scheduler started")
    
    def stop_scheduler(self):
        """Stop the scheduler"""
        self.running = False
        if self.scheduler_thread:
            self.scheduler_thread.join()
        
        self.logger.info("Scan scheduler stopped")
    
    def get_scan_history(self, scan_id=None, days=30):
        """Get scan history"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if scan_id:
            cursor.execute('''
                SELECT sr.*, ss.name 
                FROM scan_results sr
                JOIN scheduled_scans ss ON sr.scan_id = ss.id
                WHERE sr.scan_id = ?
                AND sr.run_timestamp > datetime('now', '-{} days')
                ORDER BY sr.run_timestamp DESC
            '''.format(days), (scan_id,))
        else:
            cursor.execute('''
                SELECT sr.*, ss.name 
                FROM scan_results sr
                JOIN scheduled_scans ss ON sr.scan_id = ss.id
                WHERE sr.run_timestamp > datetime('now', '-{} days')
                ORDER BY sr.run_timestamp DESC
            '''.format(days))
        
        results = cursor.fetchall()
        conn.close()
        
        return results
    
    def generate_dashboard_data(self):
        """Generate data for monitoring dashboard"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get active scans
        cursor.execute('SELECT COUNT(*) FROM scheduled_scans WHERE status = "active"')
        active_scans = cursor.fetchone()[0]
        
        # Get recent results
        cursor.execute('''
            SELECT COUNT(*), AVG(vulnerabilities_found), AVG(risk_score)
            FROM scan_results 
            WHERE run_timestamp > datetime('now', '-7 days')
        ''')
        recent_stats = cursor.fetchone()
        
        # Get scan frequency stats
        cursor.execute('''
            SELECT frequency, COUNT(*) 
            FROM scheduled_scans 
            WHERE status = "active"
            GROUP BY frequency
        ''')
        frequency_stats = dict(cursor.fetchall())
        
        conn.close()
        
        return {
            'active_scans': active_scans,
            'recent_runs': recent_stats[0] or 0,
            'avg_vulnerabilities': recent_stats[1] or 0,
            'avg_risk_score': recent_stats[2] or 0,
            'frequency_distribution': frequency_stats
        }

# Usage example
if __name__ == "__main__":
    scheduler = ScanScheduler()
    
    # Add some scheduled scans
    scheduler.add_scheduled_scan(
        "Production Network Scan",
        "192.168.1.0/24",
        "nmap",
        "daily"
    )
    
    scheduler.add_scheduled_scan(
        "DMZ Security Scan", 
        "10.0.1.0/24",
        "nessus",
        "weekly"
    )
    
    scheduler.add_scheduled_scan(
        "Web Application Scan",
        "https://app.company.com",
        "custom",
        "daily"
    )
    
    # Start the scheduler
    scheduler.start_scheduler()
    
    try:
        print("Scheduler running... Press Ctrl+C to stop")
        while True:
            # Print dashboard data every hour
            dashboard = scheduler.generate_dashboard_data()
            print(f"\\n=== SCHEDULER DASHBOARD ===")
            print(f"Active Scans: {dashboard['active_scans']}")
            print(f"Recent Runs (7 days): {dashboard['recent_runs']}")
            print(f"Avg Vulnerabilities: {dashboard['avg_vulnerabilities']:.1f}")
            print(f"Avg Risk Score: {dashboard['avg_risk_score']:.1f}")
            print(f"Frequency Distribution: {dashboard['frequency_distribution']}")
            
            time.sleep(3600)  # Sleep for 1 hour
            
    except KeyboardInterrupt:
        print("\\nShutting down scheduler...")
        scheduler.stop_scheduler()
        print("Scheduler stopped.")`}
                </pre>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
};

export default VulnerabilityScanning;
